:PROPERTIES:
:ID:       c3bb3e82-784a-4c8b-beaf-e3c9e1552ee5
:mtime:    20230206181539 20221027232743
:ctime:    20221015171321
:END:
#+title: frontend-dev

* Frontend development - Modules 18-29
** module 18 frontend foundations
*** 18.2 developer tools

Developer tools

In this lesson, you'll focus on the Chrome developer tools (sometimes referred to as DevTools).
However, many browsers have similar developer tools.

The developer tools offer several useful features, including the following:
+ The Element inspector, which allows you to inspect a particular element on the page
+ The Styles tab, which allows you to see which styles have been applied to a particular element
+ The Device toolbar, which allows you to see what your website will look like on various devices

Learning more

For now, the inspector will be your most valuable tool for working with HTML and CSS.
If you want to learn more about the developer tools (and especially Chrome's version), you can visit Google's Chrome DevTools page.
[[https://developers.google.com/web/tools/chrome-devtools][Google's Chrome DevTools]]

*** 18.3 intro to flexbox

Key Terms

Flexible box module
    Flexbox, a CSS module that provides a robust set of tools for developers to solve common layout problems

Introduction to flexbox


The flexible box module (or flexbox) provides a robust set of tools for developers to solve common layout problems, including the problem of building for various screen sizes.




Do this
Adding flexbox

.group {
  display: flex;
  flex-direction: row; /* or column */
}

Within the .group container, the default setting for displaying this container is block.
But to apply the flexbox properties to it, you should set the display property to flex.
This will tell the browser that all the items within this container should display as either a single row or a single column.

When you change the display property to flex, the default value for flex-direction is row.
If you run your code, you'll see that all three items now display within a single row.

Keeping flex-direction set as row is perfect for larger monitors.
And setting flex-direction to column is perfect for displaying the content on mobile devices.


Do this
Set the flex property
To change it so that all three items display with the same width, you can change the flex setting to 1, as shown here:

.item {
  flex: 1;
  margin: 10px;
}

The flex: 1 declaration tells the .group container that each item should be the same width, regardless of its content, and it will fill the container appropriately.

At this point, you should have three items within a group, and the items should display as equal in size.

Do this
Add margins

Set margin: 10px, as shown below. This margin is useful because it creates a little visual barrier between the .item containers. You can add or decrease this value to see what happens to the .item containers in the web page.

.item {
  margin: 10px;
}

Modifying the flex value

The flex: 1 value is currently telling the .item containers to all display at the same width.
You can change the ratio of these containers by changing the flex value to different values.

For example, you could create an additional .item-double class and set that flex value to 2.
When this is applied in addition to the .item class, the new container will display at double the size of the others within that group.

Do this
Create an .item-double class

Add the following .item-double class to your CSS file:

.item {
  flex: 1;
  margin: 10px;
}

.item-double {
  flex: 2;
}

Within the HTML, you can also create columns with different widths, as shown below. To do this, keep the original item class for all the same width elements and the margin. Then use item-double as a modifier style to override item with flex: 2 rather than creating a completely separate style.

The containers that have the item-double class will now display at twice the width of their sibling containers.

*** 18.4 intro to media queries
Overview

Media queries are a CSS feature that allows content to adapt to different screen sizes, such as mobile and desktop screens.
With a simple media query, you can easily modify a website's appearance on different devices.

Media queries

With a simple media query, you can quickly provide a responsive layout to nearly any standard website.


Media queries are essentially an if statement for CSS.
A condition is set, and if that condition is met, then the CSS rules within it will be applied.
Typically, media queries are used for changing the CSS of a website based on screen size.

The basic syntax for a media query is as follows:
@media <media type> (<media features>) {
  <CSS Rules>
}

Media types can be set to all, print, screen, or speech.
The all type, which is the most common type and the default in HTML5, applies the media query to every media type.
But if you want the styles within the media query to apply only when the web page is printed, you can use print instead.

The complete list of media features is long, but these are the most common ones:
+ width
+ height
+ orientation

Do this
Use media queries to adjust your paragraph's font size

In the style.css file, add the following rules:

p {
  font-size: 14px;
}

@media all and (min-width: 800px) {
  p {
    font-size: 24px;
  }
}

The code above is saying that the paragraph should generally display at 14 pixels in size.
The paragraph should only be displayed at 24 pixels when the browser has a width of 800 pixels or greater.

*** 18.5 mobile-first development
Overview
As you'll explore in this lesson, a mobile-first approach involves designing the mobile version of a website first, and then adapting the display to larger screens like a desktop.
When you follow a mobile-first approach, you start by building your website with your mobile users' experience in mind.

Key Terms

Graceful degradation
    A desktop-first approach that involves designing the web page layout for larger screens, then adding media queries to remove features and rearrange elements to fit a smaller screen
Progressive enhancement
    A mobile-first approach that involves designing for the smallest screen first, then progressively adding features and rearranging the layout to take advantage of larger screen sizes
Viewport
    The area of a browser's window in which web content can be seen

Mobile-first development


There are two approaches to media queries.

The more traditional approach is known as graceful degradation.
Graceful degradation is a desktop-first approach that involves designing the web page layout for larger screens, then adding media queries to remove features and rearrange elements to fit a smaller screen.
It's considered the old way of creating responsive websites.

The code below represents this traditional desktop-first approach; this kind of approach is built for desktop screens and then adapted for smaller screens.
This code assigns the background of a website shown on a desktop to be green.
However, if a screen's width is smaller—specifically, if the width is between 0 and 600 pixels—the code will assign the background to be red.

body {
  background-color: green;
}

/* This applies from 0px to 600px */
@media all and (max-width: 600px) {
  body {
    background-color: red;
  }
}

The newer and preferred method is known as progressive enhancement.
Progressive enhancement involves designing for the smallest screen first, then progressively adding features and rearranging the layout to take advantage of larger screen sizes.

As it turns out, progressive enhancement ensures that there is a good enough user experience on all screens.
Designing your pages to work on smaller screens first is the generally accepted approach to making web pages today.

The code below is targeting mobile-first design.
It assigns the background of the website to be red.
However, if a screen width has 600 or more pixels, like on a desktop computer, the code will assign the background to be green.

body {
  background-color: red;
}

/* This applies from 600px and larger */
@media all and (min-width: 600px) {
  body {
    background-color: green;
  }
}

Do this
Implement a mobile-first responsive flexbox

Before you add any media queries to your projects in these lessons, you should first make your project adhere to mobile-first design.

Adjust your screen width to below 800 pixels, to display the smaller screen view.
Notice that the items are arranged horizontally on the same row.
Ideally, they'd be stacked vertically on a small screen.

To do this, you just have to alter how .group classes display; change the flex-direction from row to column, as in the code below:

.group {
  display: flex;
  flex-direction: column;
  margin-bottom: 100px;
}

Now, you can add a media query after the .group and .item classes, like this:

/* Groups and items (Desktop) */

@media all and (min-width: 800px) {
  section,
  h1 {
    padding: 0 10%;
  }

  .group {
    flex-direction: row;
  }
}

Here's a breakdown of the syntax above:

+ The media query @media all and (min-width: 800px) is saying to only apply these CSS rules when the web browser is 800 pixels or larger.

+ When this condition is met, it adds a bit of padding to each <section> and <h1> element.

+ Then, it changes the flex-direction of each group; on larger browsers, the flex-direction becomes row instead of column. This displays the columns appropriately, as you can see in the image below of this code displaying on a larger browser.



Viewport

<meta name="viewport" content="width=device-width">

The viewport is the area of a browser's window in which web content can be seen.
Mobile devices usually render the page as if it were to be displayed on a larger screen, then shrink it to fit within the visible area.
However, if your page is already optimized to work with the small screen, this may cause a suboptimal experience.
The viewport meta tag was introduced to help with this problem; this tag lets you control the way that your pages are scaled when rendered by the browser.

For this meta tag to display the website properly on all devices, you need to add initial-scale=1.
When the initial scale is set to 1, it keeps the same zoom scale.
This presents the text much better as web pages change between vertical and horizontal views.

For any responsive web page, this entire tag is required:

<meta name="viewport" content="width=device-width, initial-scale=1">

Responsive images

Working with images inside responsive layouts can get a little complicated; it would be really difficult to track the changing .item container sizes and then update the image sizes appropriately.
Luckily, there is a very easy solution here: you can set all the image widths to be 100% using CSS, and the images will match whatever container width that they are placed within.

Do this
Adding images to group items

The files for this part of the lesson are stored in the responsive-images folder. Start by opening the index.html file with VSCode Live Server.

Notice that the images displayed in the browser are very large. So now, make them responsive.

Add the following code to the style.css file. Set the width of images to 100%, as follows:

img {
  width: 100%;
}

This code sample targets all the images within the .group container to display at 100%.
If you don't want to force the 100% resizing of every image, you can be more selective in how you target your images.

This code below, for example, will target only the images within the main container to be 100% in width.
Try it out in style.css by replacing the previous CSS code snippet with the following:

main img {
  width: 100%;
}

Because the img and main img selectors target the same images on the page, you won't actually see a visual difference between using img versus main img in this example.

But the four items that are pictures of the ocean aren't.
This is an example of why it is important to understand image size ratios.
When the images aren't the same height and width (in other words, when they have different ratios), they won't display properly.
To get these images to align properly, you need to crop them so that they all have the same ratio.
Images of different sizes that aren't aligned properly.

Most designers use graphical programs like Adobe Photoshop to edit images.
Luckily, there are also alternative apps online that make this process easy.
Of course, third-party tools available for free could disappear anytime.
But hopefully the tool shown below, [[https://www.birme.net/][BIRME]], can help if you find that you need to resize images for your own projects.

*** 18.6 deeper with flexbox

Key Terms

Main axis
    The row or column orientation established by the flex-direction property
Cross axis
    The axis perpendicular to the main axis


Flexbox properties

Certain properties are applied to the group (or parent), and other properties are applied to the items nested within the group (or children).

The following is a list of parent properties:

+ flex-direction
+ flex-wrap
+ justify-content
+ align-items
+ align-content

And here is a list of children properties:

+ order
+ flex-grow
+ flex-shrink
+ flex-basis
+ align-self

Group (parent) properties
The flex-direction property

The flex-direction property establishes the main axis, telling the items to display as either a horizontal row or vertical column.
There are also two other values, row-reverse and column-reverse, which reverse the display order of the items.
The following table summarizes the possible values for the flex-direction property.

Value Effect:
+ row :: Left to right (the default)
+ row-reverse :: Right to left
+ column :: Top to bottom
+ column-reverse :: Bottom to top

The flex-wrap property

By default, the items within a flex group container will display on a single line.
This can be changed to allow items to wrap as needed with the flex-wrap property, as described in the table below.

Value Effect:
+ nowrap :: All flex items will be on one line. This is the default.
+ wrap :: Flex items will wrap onto multiple lines from top to bottom.
+ wrap-reverse :: Flex items will wrap onto multiple lines from bottom to top.

The justify-content property

This is a useful property when there is available space around the items of the group.
That space can be distributed in various ways, as described in the table below.

Value Effect:
+ flex-start :: Items are packed toward the start of the flex direction. This is the default.
+ flex-end :: Items are packed toward the end of the flex direction.
+ center :: Items are packed centered along the line.
+ space-between :: Items are evenly distributed along the line; the first item is on the start line and the last item is on the end line.
+ space-around :: Items are evenly distributed, but have a half-size space on either end.
+ space-evenly :: Items and spacing are both evenly distributed.

The align-items property

This property is similar to the justify-content property, but it aligns items on the cross axis, which is perpendicular to the main axis that is used in the justify-content property
The following table summarizes the possible values for the align-items property:

Value Effect:
+ stretch :: Items are stretched along the cross axis to fill the container, but any defined minimum and maximum item widths are still respected. This is the default.
+ flex-start :: Items are placed at the start of the cross axis.
+ flex-end :: Items are placed at the end of the cross axis.
+ center :: Items are centered on the cross axis.
+ baseline :: Items are aligned along their baseline.

The align-content property

This property will apply only when there is more than one line of flex items.
When there is extra space in the cross axis, it will align the flex group on that axis (similar to how justify-content aligns individual items on the main axis).
The following table summarizes the possible values for the align-content property:

Value Effect:
stretch :: Items stretch along the cross axis to take up the remaining space. This is the default.
flex-start :: Items are packed to the start of the container's cross axis.
flex-end :: Items are packed to the end of the container's cross axis.
center :: Items are packed in the center of the container.
space-between :: Items are evenly distributed with the first line at the start and the last one at the end of the container.
space-around :: Items are evenly distributed with equal space around each line.
space-evenly :: Items are evenly distributed with equal space around them.

Item (child) properties
The order property
By default, flex items will display in the order they are added to the HTML page.
But with the order property, the items in the flex container can be adjusted.
This can be useful if you want the items ordered one way for mobile and another way for desktop.

The flex property
The flex property for items is actually shorthand for three properties:

+ flex-grow
+ flex-shrink
+ flex-basis

These properties are all tied to items, and it is recommended to use this shorthand property instead of setting the individual properties.
The default is 0 1 auto, which assigns flex-grow to 0, flex-shrink to 1, and flex-basis to auto.
But if you set the flex property with a single number value, like 1, the shorthand will use the single value to define the flex-grow property and will then set the other values appropriately.

The flex-grow property

The flex-grow property is quite useful.
By default, the value is set to 0.
If an item is set to 1, it will size all the items equally, so that they are all the same size.
If an item is set to 2, it will set the size of that item as twice as large as the other items.

The align-self property
This property lets the default alignment (or the one specified by align-items) be overridden for individual flex items.

Flexbox layouts

There are many great online resources that demonstrate different layout patterns using flexbox.
If you'd like to see some example flexbox layouts with CSS, visit [[https://tobiasahlin.com/blog/common-flexbox-patterns/][Common CSS Flexbox Layout Patterns with Example Code]].

Helpful games and resources

For practice using flexbox, you can play around with flexbox properties using the games and apps listed below.

    Flexbox Defense teaches flexbox via a casual strategic defense game.
http://www.flexboxdefense.com/
    Flexbox Froggy is a game that lets you practice writing CSS code.
http://flexboxfroggy.com/
    Flexy Boxes shows code samples and allows you to change parameters to help visualize how flexbox works.
https://the-echoplex.net/flexyboxes/
    Flexbox Patterns features many flexbox examples.
https://www.flexboxpatterns.com/
*** 18.7 navigation

Navigation
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to build a responsive navigation.
Overview

Some common components of websites can be tricky to build if you don't know the methodology behind them. One of those tricky components is navigation; building a responsive navigation requires a bit of knowledge of how it's typically done. In this lesson, you'll learn how to build a responsive navigation step by step.
Starter code

This lesson continues using the project that you created in the previous lesson. If you need to, you can download that code here:

    GitHub: Front-end Foundations Starter

The files for this lesson are stored in the navigation folder. To get started, open the index.html file with VSCode Live Server. You will see a page with some plain, unstyled elements. You will be using the same repository in the next lesson, so make sure to save the work that you complete in this lesson.
Responsive navigation

Building navigation in responsive web design can be challenging—especially while maintaining a consistent look, feel, and experience on your site. There are many different ways to build and style a responsive navigation; this lesson will explore one of those ways.

When you learned about flexbox and media queries earlier in this module, you were introduced to all of the code that you'll use to create responsive navigation. In this lesson, you'll go over the code step by step so that you have a solid understanding of how to apply those skills to a common web component.
Mobile-first approach

As you learned earlier in this module, it's best to build websites using the mobile-first approach. You'll be building the navigation that you can see in the image below:
The navigation you'll be building.

Now, you will learn how to build this CSS code piece by piece. You'll look at the CSS selectors that you need to target the various HTML elements, and you'll learn how to write declaration blocks that style each selected element to match the navigation shown in the image above.

For each selector, the HTML element that the CSS selector targets will be marked by a red border (border: 1px solid red;). This will help you visually connect the code with the element and the space that it occupies in each of the images below.
Do this

Make sure to keep the style.css file open in VS Code, as you will be adding CSS code to that file for the remainder of this lesson.
Style the header
Navigation with a styled header.

The header selector is the primary container to hold both the name of your page and its navigation.

Add the following CSS to style the header:

header {

  /* Sets background color to black. */

  background-color: #000;

  /* Adds 40 pixels of space under the header

     so that the main content isn't so close

     to the navigation. */

  margin-bottom: 40px;

}

Do this
Style the title of your document
Navigation with a styled title.

The header h1 selector targets the title of your document. Adding a unique font will give this text more style, too.

Add the following CSS to style the title of your document:

header h1 {

  /* Sets text color to white. */

  color: #fff;

  /* Centers the text. */

  text-align: center;

  /* Removes the default margin and spacing around the `h1` element. */

  margin: 0;

  /* Pushes the text down 20 pixels from the top of the page. */

  padding-top: 20px;

}

Do this
Style the container for the navigation
Navigation in a styled container.

The header nav selector targets the container for the navigation. Targeting only the nav container that's within the header allows for other navigation containers to be styled differently in the footer or elsewhere on the page.

Add the following CSS to style the container for the navigation:

header nav {

  /* Changes the display property from its default to `flex`. */

  display: flex;

  /* Centers an element defined as `display: flex`. */

  justify-content: center;

}

Do this
Style the unordered list
Navigation in a styled unordered list.

This header nav ul selector targets the unordered list that is within the header's nav container.

Add the following CSS to style the unordered list:

header nav ul {

  /* Changes the display property from its default to `flex`. */

  display: flex;

  /*

    You want the navigation to display in a single row. This is 

    the default value for `display: flex`, so you don't need

    to define its `flex-direction` in this case.

  */


  /*

    Removes the default padding to the left of the

    unordered list.

  */

  padding-left: 0;


  /*

    Removes the bullet points from the list items within the 

    unordered list.

  */

  list-style: none;

}

Do this
Style the anchor tags of the list items
Styled anchor tags of the list items.

The header nav ul li a selector targets the anchor tag (link) of the list items within the unordered list that is within the header's nav container.

Add the following CSS to style the anchor tags:

header nav ul li a {

  /* The link color is white. */

  color: #fff;

  /* Removes the underline from the link. */

  text-decoration: none;

  /* Applies 20 pixels of margin to the right of each link 

     creating a visual gap between the navigation links. */

  margin: 0 20px 0 0;

}

Do this
Style the last list item's anchor
Last list item of the navigation is styled.

The header nav ul li:last-child a selector targets the last list item's contained anchor (link).

Add the following CSS to style the last list item's anchor tag:

header nav ul li:last-child a {

  /* Removes the margin to the right of the last anchor tag 

     so that the nav appears centered. */

  margin-right: 0;

}

Great job on making it this far in the lesson! So far, you've created a navigation bar for the mobile view using flexbox. Next, you will add a media query for the desktop view.
Media query for desktop

As mentioned earlier, the code that you've worked through so far was designed to be viewed on mobile devices. To tell the browser how to change the header, title, and navigation when viewed on a desktop, you need to add a media query for desktop.
Do this
Add a media query

Add the following media query for desktop:

/* When a web browser is larger than 600 pixels,

   apply these rules. */

@media all and (min-width: 600px) {

  header {

    /* Changes the default setting from `block` to `flex`. */

    display: flex;

    /* Pushes the items (the title and nav) to the far sides of the 

       browser with space between them. */

    justify-content: space-between;

    /* Adds 0 pixels padding top and bottom, and 30 pixels padding 

       left and right. */

    padding: 0 30px;

  }


  header h1 {

    /* Sets 14 pixels of margin above and below the `h1` and sets 

        0 pixels of margin to the left and right. */

    margin: 14px 0;

    /* Removes or sets 0 pixels of padding above the `h1`. */

    padding-top: 0;

  }


  header nav {

    /*

      Pushes the navigation container down by 8 pixels to make it

      present a little better visually within the space.

    */

    margin-top: 8px;

  }

  /* Users cannot hover on mobile devices, so that is why you

     implement this behavior only for larger screens. */

  header nav ul li a:hover {

    /* Targets the change when a user holds the pointer over the anchor tag 

       (link) within the list items within the unordered list that 

       is within the navigation that is within the header. */

    color: #bdbdbd;

  }

}

At this point, your navigation bar will be fully responsive. Try it out in the browser.
Linking navigation

There are different navigation rules depending on if you are creating a single-page website or a multipage website.
Single-page navigation

When you create a single-page website, you'll add anchor IDs to the sections or other primary containers in your page. Don't forget to add the hash symbol # in the link; this will tell the link to look for the anchor ID somewhere on the page and jump to it when clicked. The navigation will look like this:

<header>

  <div class="title">Your Name</div>

  <nav>

    <ul id="menu">

      <li><a href="#home">Home</a></li>

      <li><a href="#about">About</a></li>

      <li><a href="#portfolio">Portfolio</a></li>

      <li><a href="#contact">Contact</a></li>

    </ul>

  </nav>

</header>

<main>

  <section id="home">

    <!-- All the Home section can be placed here. -->

  </section>

  <section id="about">

    <!-- All the About section can be placed here. -->

  </section>

  <section id="portfolio">

    <!-- All the Portfolio section can be placed here. -->

  </section>

  <section id="contact">

    <!-- All the Contact section can be placed here. -->

  </section>

</main>

Multi-page navigation

When you're linking to other pages that are all within the same directory, the navigation will look like this:

<header>

  <div class="title">Your Name</div>

  <nav>

    <ul id="menu">

      <li><a href="/">Home</a></li>

      <li><a href="about.html">About</a></li>

      <li><a href="portfolio.html">Portfolio</a></li>

      <li><a href="contact.html">Contact</a></li>

    </ul>

  </nav>

</header>

Tip

Websites usually set the home page link to the public root ("/"). This is because index.html is the default file in that directory, so it hides the /index.html filename from displaying in the browser address.
Complete example

A completed example from this lesson can be found here:

    GitHub: Front-end foundations — Navigation solution


**** Mobile-first approach


Now, you will learn how to build this CSS code piece by piece. You'll look at the CSS selectors that you need to target the various HTML elements, and you'll learn how to write declaration blocks that style each selected element to match the navigation shown in the image above.

For each selector, the HTML element that the CSS selector targets will be marked by a red border (border: 1px solid red;). This will help you visually connect the code with the element and the space that it occupies in each of the images below.
**** Do this

Make sure to keep the style.css file open in VS Code, as you will be adding CSS code to that file for the remainder of this lesson.
Style the header
Navigation with a styled header.

The header selector is the primary container to hold both the name of your page and its navigation.

Add the following CSS to style the header:

header {

  /* Sets background color to black. */

  background-color: #000;

  /* Adds 40 pixels of space under the header

     so that the main content isn't so close

     to the navigation. */

  margin-bottom: 40px;

}

**** Do this
Style the title of your document
Navigation with a styled title.

The header h1 selector targets the title of your document. Adding a unique font will give this text more style, too.

Add the following CSS to style the title of your document:

header h1 {

  /* Sets text color to white. */

  color: #fff;

  /* Centers the text. */

  text-align: center;

  /* Removes the default margin and spacing around the `h1` element. */

  margin: 0;

  /* Pushes the text down 20 pixels from the top of the page. */

  padding-top: 20px;

}

**** Do this
Style the container for the navigation
Navigation in a styled container.

The header nav selector targets the container for the navigation. Targeting only the nav container that's within the header allows for other navigation containers to be styled differently in the footer or elsewhere on the page.

Add the following CSS to style the container for the navigation:

header nav {

  /* Changes the display property from its default to `flex`. */

  display: flex;

  /* Centers an element defined as `display: flex`. */

  justify-content: center;

}

**** Do this
Style the unordered list
Navigation in a styled unordered list.

This header nav ul selector targets the unordered list that is within the header's nav container.

Add the following CSS to style the unordered list:

header nav ul {

  /* Changes the display property from its default to `flex`. */

  display: flex;

  /*

    You want the navigation to display in a single row. This is

    the default value for `display: flex`, so you don't need

    to define its `flex-direction` in this case.

  */


  /*

    Removes the default padding to the left of the

    unordered list.

  */

  padding-left: 0;


  /*

    Removes the bullet points from the list items within the

    unordered list.

  */

  list-style: none;

}

**** Do this
Style the anchor tags of the list items
Styled anchor tags of the list items.

The header nav ul li a selector targets the anchor tag (link) of the list items within the unordered list that is within the header's nav container.

Add the following CSS to style the anchor tags:

header nav ul li a {

  /* The link color is white. */

  color: #fff;

  /* Removes the underline from the link. */

  text-decoration: none;

  /* Applies 20 pixels of margin to the right of each link

     creating a visual gap between the navigation links. */

  margin: 0 20px 0 0;

}

**** Do this
Style the last list item's anchor
Last list item of the navigation is styled.

The header nav ul li:last-child a selector targets the last list item's contained anchor (link).

Add the following CSS to style the last list item's anchor tag:

header nav ul li:last-child a {

  /* Removes the margin to the right of the last anchor tag

     so that the nav appears centered. */

  margin-right: 0;

}

Great job on making it this far in the lesson! So far, you've created a navigation bar for the mobile view using flexbox. Next, you will add a media query for the desktop view.
**** Media query for desktop

As mentioned earlier, the code that you've worked through so far was designed to be viewed on mobile devices. To tell the browser how to change the header, title, and navigation when viewed on a desktop, you need to add a media query for desktop.
**** Do this
Add a media query

Add the following media query for desktop:

/* When a web browser is larger than 600 pixels,

   apply these rules. */

@media all and (min-width: 600px) {

  header {

    /* Changes the default setting from `block` to `flex`. */

    display: flex;

    /* Pushes the items (the title and nav) to the far sides of the

       browser with space between them. */

    justify-content: space-between;

    /* Adds 0 pixels padding top and bottom, and 30 pixels padding

       left and right. */

    padding: 0 30px;

  }


  header h1 {

    /* Sets 14 pixels of margin above and below the `h1` and sets

        0 pixels of margin to the left and right. */

    margin: 14px 0;

    /* Removes or sets 0 pixels of padding above the `h1`. */

    padding-top: 0;

  }


  header nav {

    /*

      Pushes the navigation container down by 8 pixels to make it

      present a little better visually within the space.

    */

    margin-top: 8px;

  }

  /* Users cannot hover on mobile devices, so that is why you

     implement this behavior only for larger screens. */

  header nav ul li a:hover {

    /* Targets the change when a user holds the pointer over the anchor tag

       (link) within the list items within the unordered list that

       is within the navigation that is within the header. */

    color: #bdbdbd;

  }

}

At this point, your navigation bar will be fully responsive. Try it out in the browser.
**** Linking navigation

There are different navigation rules depending on if you are creating a single-page website or a multipage website.
**** Single-page navigation

When you create a single-page website, you'll add anchor IDs to the sections or other primary containers in your page. Don't forget to add the hash symbol # in the link; this will tell the link to look for the anchor ID somewhere on the page and jump to it when clicked. The navigation will look like this:

<header>

  <div class="title">Your Name</div>

  <nav>

    <ul id="menu">

      <li><a href="#home">Home</a></li>

      <li><a href="#about">About</a></li>

      <li><a href="#portfolio">Portfolio</a></li>

      <li><a href="#contact">Contact</a></li>

    </ul>

  </nav>

</header>

<main>

  <section id="home">

    <!-- All the Home section can be placed here. -->

  </section>

  <section id="about">

    <!-- All the About section can be placed here. -->

  </section>

  <section id="portfolio">

    <!-- All the Portfolio section can be placed here. -->

  </section>

  <section id="contact">

    <!-- All the Contact section can be placed here. -->

  </section>

</main>

**** Multi-page navigation

When you're linking to other pages that are all within the same directory, the navigation will look like this:

<header>

  <div class="title">Your Name</div>

  <nav>

    <ul id="menu">

      <li><a href="/">Home</a></li>

      <li><a href="about.html">About</a></li>

      <li><a href="portfolio.html">Portfolio</a></li>

      <li><a href="contact.html">Contact</a></li>

    </ul>

  </nav>

</header>

Tip

Websites usually set the home page link to the public root ("/"). This is because index.html is the default file in that directory, so it hides the /index.html filename from displaying in the browser address.
*** 18.8 html forms

**** Introduction to forms
HTML forms are very useful for web users. Below are just a few examples of what they can be used for:

Sending an email through a web page

Submitting purchase order information

Completing survey questions

Collecting user registration

Here are three examples of websites that make very good use of HTML forms:

First example of a website that makes good use of HTML forms.
Image source: HotJar's registration page

HotJar uses the HTML form to collect the user's full name and email address so that they can create a free basic account.

Second example of a website that makes good use of HTML forms.
Image source: Omada's contact page

Omada uses the HTML form in three different ways: asking if the customer has a Sales Inquiry, needs User Support, or wants Something Else. This way, Omada can tailor the input fields for the HTML form to collect the data that is most useful for their team.

Third example of a website that makes good use of HTML forms.
Image source: YummyGum's contact page

YummyGum uses HTML forms in a method that's similar to Omada's usage of forms. This page filters the user through four radio buttons, and then delivers tailored input fields for each topic.

**** HTML form basics
To create an HTML form, you can begin in one of these two ways:

<form action="process-form.js" method="post">
  <!-- Add the HTML input elements here -->
</form>

<form action="baseball-stats.js" method="get">
  <!-- Add the HTML input elements here -->
</form>
The <form> element does not have any visual design by default—but of course, you can still apply a background color or a border using CSS.

Within each <form> element are two attributes: an action and a method.

action: This attribute holds the URL to the server-side file where the data will be sent.

method: This attribute specifies the HTTP method—post or get—that will be used with the action.

post: This method can involve anything from storing or updating data, ordering a product, or sending an email.

get: Put simply, this method is used to retrieve data to display in the form.

There are various kinds of form fields that you can add to a form, including, but not limited to:

Text fields

Text areas

Radio buttons

Checkboxes

Drop-down list

Submit and reset

Fieldset and legend

Password field

You'll explore these commonly used form fields next.

**** Text fields
First name text field.
<form>
  <label for="name">First name:</label>
  <input id="name" type="text" name="name" />
</form>
The example above has two HTML elements: a label and an input.

The label tells users what information needs to go in a text field. It's connected to the input element with the for attribute as it links to the input's id.

The label is also important for accessibility. Assistive technologies such as screen readers use the label to tell the user what text should go in the text field. The label also makes it easier for users to interact with the text field by providing a larger hit area to click or touch.

The input has three attributes:

id: The id attribute gives the element a unique name so that the label knows how to connect with it.

type: The type attribute determines what type of control to render (for example, whether the user clicks a radio button, checks a checkbox, or enters text). For a text field, the type is set to text, which creates a single line of input text.

name: The name attribute is used to identify the input field when the entire form is submitted to a server.

**** Text field options
There are three additional attributes that can be used to style the text field.

autofocus: on: The autofocus attribute will set the first input to autofocus to help draw the user's attention to it. You only want this once on your page.

required: The required attribute will tell the user that this field must be filled in before they submit the form.

maxlength: number: The maxlength value limits the number of characters added to the text field.

Here's an example of these attributes in use:

Attributes for text field styling
<form>
  <label for="location">Zipcode:</label>
  <input
    id="location"
    type="text"
    name="zipcode"
    autofocus="on"
    maxlength="5"
    required
  />
</form>
**** Do this
Add text fields to your form
In index.html, add the following code to create text fields to collect the user's name and zipcode:

<form>
  <div>
    <label for="name">Full Name:</label>
    <input id="name" type="text" name="name" />
  </div>
  <div>
    <label for="location">Zipcode:</label>
    <input
      id="location"
      type="text"
      name="zipcode"
      autofocus="on"
      maxlength="5"
      required
    />
  </div>
</form>
**** Text areas
Text area fields present the user with a multi-line input field so that they can enter an unlimited number of characters. These are best used for collecting a longer message. Here's what these fields look like:

Text area field example
As you can see in the code below, this HTML element has its own label.

<form>
  <label for="form-message">Your message:</label>
  <textarea id="form-message" name="message"></textarea>
</form>
These are the attributes that can change the way that the text area looks and works:

cols: Sets the visible width of a text area in character spaces. But it's better to use the width attribute in CSS.

rows: Sets the visible number of lines in a text area in character spaces. But it's better to use the height attribute in CSS.

autofocus: on: The autofocus attribute sets the first input to autofocus to help draw the user's attention to it. Remember, you only want this once on your page.

required: The required attribute tells the user that this field must be filled in before they submit the form.

maxlength: number: The maxlength value limits the number of characters that can be added to the text field.

**** Do this
Add text areas to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <label for="form-message">Your message:</label>
    <textarea
      id="form-message"
      name="message"
      autofocus="on"
      required
      maxlength="200"
    ></textarea>
  </div>
</form>
This form states that it is a multi-line text field that will store the data within the name message. The autofocus is set to on, the field is required, and only 200 characters can be entered.

**** Fieldset and legend
The <fieldset> element is used to group together related inputs and labels. This will help web crawlers and screen readers, even if there is no visual representation here. The <legend> element is like a title for the <fieldset>.

Here's what these elements look like:

Related elements grouped by fieldset.
**** Do this
Add a fieldset and legend to your form
In the index.html file, group your name and location input fields within a set of fieldset tags, as follows:

<form>
  <fieldset>
    <legend>Shipping Information</legend>
    <div>
      <label for="name">Full Name:</label>
      <input id="name" type="text" name="name" />
    </div>
    <div>
      <label for="location">Zipcode:</label>
      <input
        id="location"
        type="text"
        name="zipcode"
        autofocus="on"
        maxlength="5"
        required
      />
    </div>
  </fieldset>
  ...
</form>
Notice how the <fieldset> element is used to group the shipping information (i.e., name and location) together.

**** Placeholder text
The text field and text area field can both use the placeholder attribute to briefly describe the information that is expected in the field. This should just hint at what should be inputted rather than providing a full explanation; it's best to use a simple word or short phrase that demonstrates the expected type of data. The placeholder text cannot include carriage returns or line feeds.

Keep in mind that for accessibility and usability reasons, labels shouldn't be replaced by placeholders. Placeholder text disappears when the user types in the field, so if the user forgets what the form field is expecting as an input, the user would have to delete what they wrote to reveal the placeholder text again. Moreover, some screen readers may not even read placeholder text aloud.

Also, make sure that the placeholders you use have the appropriate CSS styling so that it is easy to read for your users.

Placeholder text examples.
**** Do this
Add placeholder text to the name and message fields
Add the placeholder attribute to your name and form-message fields, as follows:

<form>
  <fieldset>
    <legend>Shipping Information</legend>
    <div>
      <label for="name">Full Name:</label>
      <input
        id="name"
        type="text"
        name="name"
        placeholder="Enter your full name"
      />
    </div>
    ...
  </fieldset>
  <div>
    <label for="form-message">Your message:</label>
    <textarea
      id="form-message"
      name="message"
      autofocus="on"
      required
      maxlength="200"
      placeholder="How can I help you?"
    ></textarea>
  </div>
  ...
</form>
**** Password field
As you build more complicated forms, there may be times when you want to mask sensitive input fields by using the password field.

Password field.
Review the code below to get an idea of how the HTML works.

<div>
  <label for="password">Password:</label>
  <input id="password" type="password" name="password" minlength="8" />
</div>
The attribute minlength can be used to force the entry to be at least eight characters in length.

**** Do this
Add a password field to your form
In the index.html file, add the following password field to your form:

<form>
  ...
  <div>
    <label for="password">Password:</label>
    <input id="password" type="password" name="password" minlength="8" />
  </div>
</form>
Type into the password field and observe how the characters you type are hidden.

**** Radio buttons
Radio buttons allow the web user to select only one of the limited number of choices available. They look like this:

Radio buttons for colors.
To create a radio button, you'd have to set the type attribute of an input tag to "radio", as follows:

<input id="red" name="color" type="radio" value="red" />
The new attribute here is the value. The value is important because that is the data for the one selected item that will be submitted with the form data.

**** Do this
Add radio buttons to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <h2>Favorite Color:</h2>
    <div>
      <input id="red" name="color" type="radio" value="red" />
      <label for="red">Red</label>
    </div>
    <div>
      <input id="blue" name="color" type="radio" value="blue" />
      <label for="blue">Blue</label>
    </div>
    <div>
      <input id="white" name="color" type="radio" value="white" />
      <label for="white">White</label>
    </div>
  </div>
</form>
There is no necessary order for the radio button's parameters, so you can place the input, name, and value in any order that you wish. When you click on the text of the radio button, the color is selected. That's because of the for attribute and how it matches up with the ID of the <input> element.

**** Checkboxes
Checkboxes allow the user to select one or more options from the number of choices available. They look something like this:

Check boxes for monster features.
To create a checkbox, you'd have to set the type attribute of an input tag to "checkbox", as follows:

<input name="scales" type="checkbox" id="scales" />
**** Do this
Add checkboxes to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <h2>Choose your monster's features:</h2>
    <div>
      <input name="scales" type="checkbox" id="scales" />
      <label for="scales">Scales</label>
    </div>
    <div>
      <input name="horns" type="checkbox" id="horns" />
      <label for="horns">Horns</label>
    </div>
    <div>
      <input name="wings" type="checkbox" id="wings" />
      <label for="wings">Wings</label>
    </div>
  </div>
</form>
**** Drop-down list
A drop-down list, also called a select menu list, is a toggleable menu that allows the user to choose one value from a predefined list. It tends to be more user friendly than a list of radio buttons when there is a long list of items. Drop-down lists look something like this:

Drop-down list for fonts.
To create a drop-down list, you'd have to use the <select> tag in conjunction with <option> tags. The <select> tag accepts the following attributes:

size: This sets the display of the drop-down menu to show a specified number of items. For example, if you wanted to show a list with 4 items out of 10, you'd set the size to 4 (size="4").

multiple: This option allows for the user to choose multiple sections in the drop-down menu.

**** Do this
Add a drop-down list to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <div>
    <label for="fonts">Choose a font:</label>
    <select name="fonts" id="fonts" size="1">
      <option value="arial">Arial</option>
      <option value="times">Times New Roman</option>
      <option value="comicsans">Comic Sans</option>
      <option value="papyrus">Papyrus</option>
    </select>
  </div>
</form>
In the above code, size="1" sets the display of the drop-down menu to show a single item, with the first of the list by default. Unlike all of the other inputs, it isn't recommended to try to update the style of an HTML drop-down menu using CSS. As you learn more about JS, you'll be able to create a clickable drop-down menu without using this input at all.

**** Submit and reset
Buttons are similar to links, but they are really important to have in forms. Whereas a link is used to navigate the user to a new page or resource, a button toggles something in the interface—which makes buttons perfect for submitting or resetting the data in a form. Buttons look something like this:

Submit and Reset buttons.
There are three types of buttons:

submit: Submit buttons send the data in the form to the backend program that collects the data.

reset: Reset buttons clear all of the data that has been changed in the existing form elements.

button: Buttons with type="button" have no default behavior. They are often used to trigger client-side functions or scripts that listen to the element's events.

**** Do this
Add Submit and Reset buttons to your form
In the index.html file, add the following tags to your form:

<form>
  ...
  <button type="submit">Submit</button>
  <button type="reset">Reset</button>
</form>
Notice that the default presentation of a button looks very different compared to a link. A link may display as blue text with an underline, whereas a button is a rounded rectangle around the text.

Buttons have many uses beyond forms once you start working with JavaScript, but when you're only working with HTML and CSS, their use is usually limited to simple form controls.

**** Patterns
The pattern attribute is used to supply patterns that the user's input must match in order to be valid. A complete list of useful patterns can be found at HTML5Pattern.

For example, the pattern "\d{3}[\-]\d{3}[\-]\d{4}" will warn the user if they are not providing a correct 10-digit phone number in the xxx-xxx-xxxx format. The visual error that appears is a default with the browser.

**** Do this
Validate the phone number
Add the following phone input field, right above the Submit and Reset buttons:

<form>
  ...
  <div>
    <label for="phone">Phone #:</label>
    <input
      id="phone"
      type="text"
      name="phone"
      pattern="\d{3}[\-]\d{3}[\-]\d{4}"
      placeholder="xxx-xxx-xxxx"
    />
  </div>
  ...
</form>
An error message "Please match the requested format" will display if the phone number format is wrong when you press the Submit button.

**** More input types
There are many more input types that you can use in a form. You can find additional ones at MDN: Input Types.

** module 19 css frameworks
*** 19.1 overview: css frameworks

Key Terms
CSS framework
A library of various web design components that can be applied to multiple projects

To help with this complexity, some designers have created CSS frameworks.
A CSS framework provides various components that you can plug in to your website and thoroughly customize.
CSS frameworks can increase your productivity and help you design a clean-looking website, even if you're not a great designer yourself.

*** 19.2 using a framework

Key Terms
Content delivery network
Also known as a CDN, a network of servers that helps web page content to load more quickly
Spaghetti code
A pejorative term used for program code written without a coherent structure

**** What is a framework?
You'll often hear about CSS frameworks, but the concept of a framework actually appears across the technology stack. A framework, when applied to any language, typically refers to reusable code that provides an opinionated solution to common problems. For example, a CSS framework typically provides prestyled elements and requires that you use certain elements or classes to design your website. In short, a CSS framework is CSS that someone else wrote to help you make incredible websites.

In exchange for following a preset pattern, you gain a number of benefits from the imported code. CSS frameworks vary immensely, but almost all of them allow you to achieve some things much more quickly and easily than would be possible if you were to write all of your own CSS.

These are some time-saving functionalities that are common across most CSS frameworks:

Organizing the layout of your page

Building responsive websites

Maintaining consistency across your pages

In exchange for these benefits, you often have to do the following tasks when using CSS frameworks:

Use certain elements or class names

Organize and nest your elements in a particular way

Include external stylesheets and potentially external JavaScript

**** Examples
The most popular CSS framework by far is Twitter Bootstrap. With robust documentation and plenty of support from one of the largest tech companies, Twitter Bootstrap has come to define CSS frameworks.

In large part, this is because Bootstrap looks both simple and clean.

Screenshot of the Bootstrap home page, reading "Build fast, responsive sites with Bootstrap."
There are also other popular CSS frameworks, a few of which are listed below. Note that although each of these frameworks can differ, they have more similarities than differences.

Pure.css

Materialize CSS

Bulma

**** Customization
CSS frameworks typically provide a few CSS files to include as part of your project. But this doesn't mean that you can't write your own CSS to go on top of it!

In fact, many websites start with a CSS framework as a base, and then design on top of it. For example, all of the websites showcased on Bootstrap Expo make use of Bootstrap—and yet each one looks very different. If you're interested, take a moment to scroll through Bootstrap Expo and get an idea of what's possible with Bootstrap.

With that said, just adding CSS on top of existing CSS can lead to confusing code. It's important to be thoughtful when adding to or modifying existing CSS—and this is particularly crucial if you're working on a large project.

**** Problems
CSS frameworks can be powerful tools, but they don't come without their own problems and detractors. Here are some of the biggest complaints about CSS frameworks:

CSS frameworks can lead to what is known as spaghetti code. This occurs when developers don't understand how the CSS code they are adding to works but continue to add more and more CSS elements, making the code even more difficult to understand.

CSS frameworks often rely on <div> elements and other non-semantic elements, making pages less accessible to certain types of users.

CSS frameworks can lead to websites looking too similar to each other. When you get familiar with Bootstrap, you'll start to notice lots of websites that use Bootstrap.

As with any tool, using a CSS framework should be a conscious and active choice that you're making. You'll make use of CSS frameworks in this module, but keep in mind that a CSS framework won't always be the best decision.

**** How to add a CSS framework
Installing and getting started with using a CSS framework is quite simple; many frameworks make it as easy as possible to begin using them.

There are a few ways to include a CSS framework, depending on your setup. However, the most common method is to include a link to a file hosted on a content delivery network (CDN). A CDN is a distributed group of servers used to host files for the web. CDNs make it efficient for many people to access the same file at the same time.

To link to a CDN, you essentially add a stylesheet that has an external URL as its href value. You can usually find a framework's CDN link early on in its documentation.

**** Do this
View your index.html file
Before you add Bootstrap, use your browser to open your existing index.html file. Take notice of the style and formatting, even though there's only an <h1> element.

**** Use Bootstrap on your page
Your page will look something like the image shown below:

Your index.html page before adding bootstrap
To add Bootstrap to your page, visit Bootstrap's website and scroll down to the jsDelivr section shown in the image below.

A screenshot of the jsDelivr section on the installation page
Copy the <link> element that's referenced in that section, and add it to the <head> of your index.html page. For now, ignore any requirements to include <script> tags.

Tip
You don't need to run npm install or anything from your command line. Make sure that you look for the CDN instructions.

When you refresh your page, you will notice that the style is slightly different. You're now using Bootstrap on your page!

The index.html page after using Bootstrap

*** 19.3 grids



Key Terms
Grid
A structural system of horizontal and vertical gridlines that helps ensure that your website is well-aligned and quickly scalable
Responsive
The property of allowing a layout to change dynamically based on the size of the screen
Mobile-first
A layout where the default configuration is for narrow screen and mobile devices
CSS container
The most basic conceptual element in most frameworks, used to encapsulate and pad the rest of the page

**** The grid system
Many websites are organized in very similar ways. The existence of headers, footers, and sidebars showcases that when it comes to the design of many web pages, developers and designers rely on certain elements to convey their sites' messages.

One way that CSS frameworks make this easier is by providing a grid. A grid allows you to easily organize your website so that it is well aligned and quickly scalable. Modern CSS frameworks also include classes that make it easier to build responsive grids, making the transition from mobile to desktop seamless.

A grid in most CSS frameworks is separated into columns and rows. It's standard for most CSS grid frameworks to have 12 columns and any number of rows.

An example of a grid in CSS
In the above example, you can see 12 columns marked in dark gray. Each colored section generally represents a horizontal row.

In terms of the grid system, the following statements are true of the above image:

The header is the first row on the page. It spans all 12 columns.

The nav spans three columns, in contrast to the container that is wrapping both the content and the footer. The nav also goes across two different rows.

Both the content and the footer are included together in their own container. They span nine columns. The content and footer are each in their own separate row.

Most websites fit into this kind of structure that prioritizes containers, rows, and columns. In the following sections, you'll learn more about these concepts and how they apply to Bootstrap.

**** Do this
Grid your view
Take a look at the page on which you're currently reading this lesson. Can you visualize it as a grid? Take a moment to think about how many columns each part of the page might be, as well as how many distinct rows you see on the page.

**** Containers
A CSS container is the most basic conceptual element in most frameworks. CSS containers are used to encapsulate and pad the rest of your page. CSS containers aren't usually nested inside of each other.

If you use the grid system from Bootstrap, you will need at least one container on your page.

To make an element into a container, you simply need to add a class of .container to it. Any element can be a container, but it's most typical for the .container class to be added to a <main> or <section> element.

<main class="container">
  <!-- ... -->
</main>
**** Do this
Use a container
The best way to see what a container does is to use one. Replace your <body> code with the following code:

<body class="container">
  <h1>Hello, there!</h1>
</body>
Refresh your page to see the difference. Do you see how there's now padding to the left of the heading? This padding is provided by the container.

**** Rows and columns
Rows wrap around any elements that are grouped horizontally on the page. Rows must be inside of a container element.

As you might expect, rows use the .row class, and columns generally use the .col class.

Each row contains a number of columns. Bootstrap allows for a lot of variety in how columns are used, but columns must be inside of a <div> with a .row class element.

Take a look at the Replit below, which shows a single row with a single column in a single container.


In general, there isn't much that is remarkable about this code. But you should notice that several wrapping <div> elements are needed to make use of rows and columns.

Now, take a look at the Replit below. It makes use of two columns, and each column is outlined in a different color. If the screen is too small, try opening this Replit in its own tab.


As you might have noticed, the above Replit has two columns of equal width taking up the page. You can continue to add more columns next to each other, and each one will take up a similar width. That's because rows and columns make use of flexbox.

**** Do this
Include rows and columns
Replace your <body> element with the following code:

<body class="container">
  <div class="row"></div>
</body>
Then, add three columns inside of the .row. Add a paragraph with some text to each, so that you can see the separation.

Below, you can see a potential solution to this challenge.

<body class="container">
  <div class="row">
    <div class="col">
      <p>
        Bears are mammals that belong to the family Ursidae. They can be as
        small as four feet long and about 60 pounds (the sun bear) to as big as
        eight feet long and more than a thousand pounds (the polar bear).
      </p>
    </div>
    <div class="col">
      <p>
        They're found throughout North America, South America, Europe, and Asia.
      </p>
    </div>
    <div class="col">
      <p>
        They have nonretractable claws, short tails, and excellent sense of
        smell. They're typically solitary, except for mothers with cubs.
      </p>
    </div>
  </div>
</body>
**** Varied column sizes
In the documentation, you might have noticed .col classes with additional text next to them. When a number follows a column, as in .col-4, it defines the size of the column. Recall that the grid system is typically based on 12 columns. The .col-4 class means that the selected element will take up 4 out of the 12 columns. Any columns with a .col class will equally share the rest of the space.

In the following Replit, the first column is set to .col-9.


As you can see, this first column takes up more space than the remaining column.

**** Responsiveness
Similarly, it's possible to make your columns and rows responsive. Bootstrap is developed to be mobile-first, which means that it's assumed that users will be viewing your site on mobile.

Bootstrap has a feature that you can use to make the column sizes adapt to different screen sizes. There are four different sizing terms that you can add to your columns:

sm: For small devices and landscape phones

md: For tablets and smaller computers

lg: For desktop computers

xl: For large monitors

More information about the exact breakpoints can be found at Bootstrap's documentation on responsive breakpoints.

Here's an example:

<body class="container">
  <div class="row">
    <div class="col col-lg-8">
      <p>col col-lg-8</p>
    </div>
    <div class="col col-lg-2">
      <p>col col-lg-2</p>
    </div>
    <div class="col col-lg-2">
      <p>col col-lg-2</p>
    </div>
  </div>
</body>
In the example above, on large screens, the left column (.col-lg-8), will take up most of the space. As the screen size decreases, all of the columns will eventually end up being the same size.

**** Do this
Add responsive classes
Add responsive classes to your current work. Use a mix of lg and md classes and test out the difference.

**** Using the documentation
This lesson won't cover every single aspect of the grid system. Instead, you can explore the Bootstrap documentation. The bootstrap documentation is excellent and gives many examples.

For example, Grid: Setting one column width, which is part of Bootstrap's grid documentation, lays out information on varied column widths.

And Grid: Responsive classes describes how rows and columns can be set to be responsive.

You don't need to memorize everything on the Bootstrap website. Instead, rely on it as a tool for learning and solving problems.

*** 19.4 common components and utilities

**** What else can Bootstrap do?
CSS frameworks gained popularity through the grid system, but many of these frameworks now also include common components and utility classes that you can add to your website. This makes it easy to quickly add common styling. In the following sections, you'll learn about some of the most common components and classes. Wherever possible, links to the appropriate documentation will be included.

**** Common components
There are too many components to cover here, and many of them have already been described on the Bootstrap website. For demonstrations of available components, visit Bootstrap's page on components.

Below is a list of some of the most common components:

Alerts

Buttons

Card

Forms

Jumbotron

Navs

You can use these components in Bootstrap and other frameworks.

Some components require supporting JavaScript files to use. Although you can use these components, it's suggested that you actually avoid them until you've learned more about using JavaScript with HTML and CSS.

The components described above require the use of certain classes and structures to make them work. Note that the majority of these are intended to be used inside of a container, row, or column.

**** Do this
Include common components
Add a styled button to your page. To keep things organized, make sure that it appears inside of a .col class. Try changing the color and size using the various classes described.

Next, add a card to your page. Try placing it inside a column and adding or removing elements.

**** Borders and colors
There are a few classes in Bootstrap that allow you to add borders and colors to your containing elements. These are easy to use and can be useful for quickly adding a bit of style to your code.

You can explore the documentation using the links below:

Bootstrap: Borders
Bootstrap: Colors
**** Do this
Use borders and colors
Use the .border border-primary class, the .text-danger class, and the .bg-dark class on your page.

**** Text
Bootstrap allows utility classes that you can use to modify text in a variety of ways.

You can explore the documentation here:

Bootstrap: Text
Perhaps the most useful text-modification classes are those that allow you to align your text quickly, like .text-center.

**** Do this
Align your text
Use the .text-center class on your index.html page. Notice from the documentation that this class also allows for responsive text!

**** Spacing
Bootstrap also provides a few utility classes that make it easy to add margins or padding to elements. These rely on a lot of abbreviations, so you'll need to read the documentation carefully.

You can explore the documentation here:

Bootstrap: Spacing
**** Do this
Add margin and padding
Try using the .py-2 class and .mb-4 class. What does each abbreviation represent?

**** Flex
It's important to know that Bootstrap can't solve every layout problem with rows and columns. Some layout problems require a more nuanced solution.

Bootstrap provides some utility classes that allow you to apply CSS rules to individual elements. For example, there are a few classes that just apply flexbox rules to elements.

You can explore the documentation here:

Bootstrap: Flex
Note that using these classes can conflict with rows and columns. That doesn't mean that you can't use them together; just be wary of overlapping styles!

** module 20 javascript and the DOM
*** 20.2

Key Terms
Document Object Model
DOM, the data representation of the HTML elements that make up the structure of a web page, serving as a way for JavaScript to understand the structure of an HTML page in order to make it dynamic
Child element
An element that's nested inside another element
Parent element
An element that has one or more elements nested inside it

**** Why use JavaScript?
JavaScript was originally designed to work with HTML on a web page. When applied to a web page, JavaScript is used to add some interactivity or to make the page more dynamic. You may have seen websites that use JavaScript to do the following:

Create animations

Respond to actions that the user performs

Validate user input on forms

Load data dynamically

**** The <script> tag
To include some JavaScript on a page, add an HTML <script> tag to the bottom of the <body> element. The <script> tag takes an attribute named src; this attribute specifies the JavaScript file to be included. Here's an example:

<script src="/path/to/your/script.js"></script>
If your browser happens across a <script> tag when it's rendering a requested web page, it will request the file and execute it immediately.

**** Do this
Create two files
On your machine, create a new folder for a new project. In that folder, create two files named index.html and index.js. The index.html file is a simple HTML page with a <script> tag referencing index.js. Copy the following code into the respective files.

Here's the code for the index.html file:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript on your page</title>
  </head>
  <body>
    <h1>Welcome to my website</h1>
    <script src="index.js"></script>
  </body>
</html>
And here's the code for the index.js file:

console.log("Hello!");
Once you've added the code to both files, open the HTML page in your browser and observe the console in the developer tools. Notice that the JavaScript code is executed as the page loads.

**** Embedding JavaScript
In addition to linking to an external file, you can include JavaScript directly on the HTML page within the <script> tags. Here's an example:

<script>
  console.log("This is embedded JavaScript");
</script>
But generally, it's best to avoid embedding JavaScript in an HTML page like this; it isn't a very scalable solution.

**** Do this
Add some <script> tags
Add a few <script> tags to the HTML page from above, and open it in the browser. Each set of tags may simply log some text. Notice that each <script> tag is executed in turn as the page loads.

Tip
The <script> tags should be added to the bottom of the <body> element.

**** The <noscript> tag
What happens if one of your users cannot run your script? You still want that user to have a good experience on your website. Some users deliberately turn off scripts or may be unable to run scripts for a number of reasons. At the very least, you should show these users a message indicating that the website depends on scripts. To do so, use the <noscript> tag, like this:

<noscript>This site requires JavaScript.</noscript>
To see this in action, you will need to temporarily disable JavaScript in your browser.

**** Do this
Add <noscript> to page
Add the <noscript> tags (as shown above) to the HTML page. Then reload the page in the browser.

**** Disable JavaScript
Open the Chrome DevTools console by pressing Control+Shift+J (or Command+Option+J on a Mac). Then press Control+Shift+P (or Command+Shift+P on a Mac) to open the command palette.

The Chrome DevTools console
Type javascript to filter the commands to show only those that relate to JavaScript.

Type javascript to filter the commands
Click the Disable JavaScript option, and JavaScript will be disabled in your browser. Try reloading the page, and observe that the <noscript> tag kicks in now that JavaScript isn't available.

**** Document Object Model
When your web page is loaded by the browser, it is parsed, and the browser constructs an internal representation of the HTML. This facilitates the browser's interaction with the HTML. You can also use JavaScript to interact with the HTML via this internal representation. This representation, which is called the Document Object Model (DOM), is the data representation of the HTML elements that make up the structure of a web page. The DOM is how the browser sees your HTML.

Consider the following simple HTML file:

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript on your page</title>
  </head>
  <body>
    <header>
      <h1>List of Parks</h1>
    </header>
    <main>
      <ul>
        <li>Biscayne</li>
        <li>Grand Canyon</li>
        <li>Gateway Arch</li>
        <li>Indiana Dunes</li>
      </ul>
    </main>
  </body>
</html>
Notice that the entire document is enclosed in the <html> element. The <html> element is called the root of the DOM.

Observing carefully, you can see that there are two elements directly inside the <html> element: the <head> and the <body>. These are called the children of the <html> element, and the <html> element is the parent of these two elements. The following diagram illustrates this relationship:

Parent and children elements
A parent element nests other elements. An element that is nested inside another element is called a child element.

As you examine the HTML document further, you can see that the <body> element itself also nests some elements. That is, <header> and <main> are children of <body>. Additionally, the <h1> inside the <header> is a child of the <header>. And <main> contains a <ul>, which in turn contains four <li> elements. You can also see that the <head> element has three children.

All of these relationships can be added to the diagram. The result, shown below, is a complete diagram of the DOM the way that the browser represents it.

Diagram of the DOM the way that the browser represents it
You may have noticed that the structure of the DOM resembles a family tree, except that each child has a single parent. The family tree terminology is used when talking about the relationships between the elements of the DOM. You may refer to the parent of an element, the grandparent of an element, the siblings of an element, and so on.

**** Summary
As you learned in this lesson, adding JavaScript to an HTML page is as simple as adding a <script> tag to the page. Although it is possible to write JavaScript directly on the page, it is preferred to link to external JavaScript files.

The DOM is a treelike structure used by the browser to represent and interact with the HTML document.

*** 20.3


Key Terms
Node
An element in a tree structure
NodeList
A list of elements that match a given selector

**** Exploring the HTML
Before you start writing code to work with this HTML, examine the HTML a bit and see if you can think of it in terms of the DOM. Look at the index.html file and try to think about what the DOM structure may be.

You can see that in the <body>, there is a <main> containing four <section> tags. Each of these contains the details of one park. Look carefully at the structure of the HTML in those <section> tags.

**** Do this
Sketch the DOM
Use a piece of paper (or any online drawing tool) to quickly sketch the DOM structure diagram for one of these sections. Do not spend more than five minutes on this exercise. When you are done, compare your sketch to the illustration below.

The following diagram shows one possible solution; note that it shows only part of the DOM. For convenience, siblings are colored the same, and the class names have been included.

DOM structure diagram
**** Accessing the DOM
The browser makes all of the page's HTML accessible via a global variable named document. This variable is available to your JavaScript and contains a reference to the entire HTML document. You can see this by logging the document variable and observing it in the console.

**** Do this
Log the document variable
Add the following code to the index.js file and reload the page in the browser.

console.log(document);
Then open Chrome DevTools and take a look at the console.

Chrome DevTools console with document
Notice that the entire HTML document is logged to the console. You can use the expander arrows to drill down into the document and verify that all of the elements of the HTML are present.

**** Finding an element with querySelector()
Now that you have access to the entire HTML document, you can try to select some elements in the DOM. You can use the built-in querySelector() method to search the DOM. The querySelector() method accepts a string representing a CSS selector. Then it returns the first element in the DOM that matches that selector.

For example, to find an <h1> element on the page, you can use the following syntax:

const heading = document.querySelector("h1");
console.log(heading);
Place the above code in the index.js file and reload the page in the browser. The querySelector() method will traverse the DOM, starting from the root, and find the first <h1> element. In the case of the example web page, the first <h1> element is <h1>National Parks</h1>.

**** Selectors
In the querySelector() example above, the string "h1" was used as a selector. What are some of the other ways that you can specify selectors?

Well, there is a very simple rule: a selector is any valid CSS selector.

You have already seen several types of CSS selectors. Here are just a few of them:

Selector
Description
Examples
Type selector
Targets any HTML element name
h1, p, section
Class selector
Targets elements based on the value of the class attribute
.location, .stats
Id selector
Targets elements based on the value of the id attribute
#rating, #area
Note that in the selector string, a period . prefix is used to indicate a class, and a hash symbol # prefix is used to indicate an ID.

All the CSS selectors are fully documented on MDN's CSS selectors page. You may use any of those selectors as an argument for querySelector().

**** Do this
Select elements
For each of the elements described below, write a statement in the index.js file to find the element. To check that you found the right element, you may log the element that you find to the console.

Find an element with the class value.

Find a <button> element.

Find an element with the class area.

Find a <div> that is a descendant of an element with the class stat. (Hint: Look up descendant selectors in the documentation).

Find an element with the class hello. Take careful note of what is returned there.

**** Collections of elements with querySelectorAll()
You may have noticed that querySelector() returns the first matched element in each example above. But what if you wanted to get all the matched elements? For that, you can use querySelectorAll(). The querySelectorAll() method accepts a string representing a CSS selector. It then returns a list of elements that match the selector.

The selector used for querySelectorAll() follows the same format as with querySelector(). The main difference is that querySelectorAll() returns a list of all matched elements.

**** Do this
Find all <button> elements on the page
Add the following code to the index.js file and reload the web page in the browser.

// Find all the buttons on the page
const buttons = document.querySelectorAll("button");
console.log(buttons);
Then look at the console to see what was logged. You'll see something like this:

Buttons logged to the DevTools console
You may use the expander arrows to drill down into the elements if you wish.

**** Working with NodeList
When you logged the value returned by the querySelectorAll() method, it stated that it was a NodeList. But what exactly is a NodeList?

Node is a term used to describe an element in a tree structure. Sometimes, the elements in the DOM are referred to as nodes, because the DOM is a tree structure. A NodeList, then, is a list of elements that match the selector.

Typically, you'll want to iterate over the list of elements found and process them in some way. The NodeList isn't an array, but it provides several properties and methods that allow it to be processed like an array.

You can iterate over the NodeList using the values() method, as shown below:

// Get a list of all `<h3>` elements
const heading3List = document.querySelectorAll("h3");

// Iterate over the list and print each one
for (let element of heading3List.values()) {
  console.log(element);
}
Or you can use a simple for loop to iterate over the NodeList, like this:

for (let i = 0; i < heading3List.length; i++) {
  const element = heading3List[i];
  console.log(element);
}
Notice that in this second example, the length property of the NodeList and the square bracket [] notation are used to access individual items in the NodeList.

**** Do this
Use querySelectorAll()
First, run the two examples above to verify that they behave the way that you expect. Then try the following:

Get a list of all the <div> elements containing ratings on the page. Log them to the console using the values() method.

Get a list of all the <div> elements containing areas on the page. Log them to the console using a simple for loop.

**** Supporting older browsers
Very old browsers (and Internet Explorer in particular) don't fully support the NodeList interface. As such, the code above may not work as intended. If you need to support Internet Explorer, you can use the Array.prototype.forEach() method, like this:

// Get a list of descriptions
const list = document.querySelectorAll(".description-display");

// Log them to the console
Array.prototype.forEach.call(list, function (element) {
  console.log(element);
});
Note: Recall that in JavaScript, arrays are list-like objects. The Array class is used to construct new arrays. The prototype constructor is commonly used to add new properties and methods to the Array object. You can find a list of available instance methods for Array.prototype in Mozilla's JavaScript Reference.

*** 20.4

**** Modifying an element
Once an element has been selected using querySelector() or querySelectorAll(), you have access to many of its properties and can change some of them. In this section, you'll learn how to implement three common changes that may be made to an element. You'll learn how to change the text contained in an element, change the value of an attribute, and change the CSS style of an element.

**** Changing the content
When you look at the National Parks example web page, you can see that the descriptions of the various parks are all of different lengths. Suppose that you wanted to limit the length of these descriptions to 250 characters and add an ellipsis ... to those that were truncated.

First, you will have to select all the descriptions on the page. You can use a class selector, because all the descriptions are in <div> elements with the class description. Here's an example:

const descriptions = document.querySelectorAll(".description-display");
Next, you will iterate through the list of descriptions and get the text for each one. Each item returned by querySelectorAll() is of type HTMLElement. HTMLElement is a built-in interface that exposes properties and methods common to all elements that are found in an HTML document. HTMLElement is fully documented on MDN's HTMLElement page.

**** The innerText property
One of the properties exposed by the HTMLElement interface is the innerText property. The innerText property contains any text that is contained between the opening and closing tags of the element.

For example, you can iterate through the descriptions and log the innerText value of each description, like this:

for (let desc of descriptions.values()) {
  let content = desc.innerText;
  console.log(content);
}
**** Do this
Log each description
Write the code above in the index.js file and reload the page in the browser. Notice that the description text of each park is logged to the console.

Truncate the text
You can now use string methods to truncate these strings to 250 characters and add ellipses if they are longer than that. You can use the slice() method.

Now, try updating the text using the slice() method to allow for only 250 characters.

If you get stuck, you can consult this solution:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + "...";
  }

  console.log(content);
}
Once you've accomplished this, observe that each description is truncated and ellipses are attached to the ends. The only exception is the description for Gateway Arch park; that description was already shorter than 250 characters.

Update the HTMLElement
You can now update the HTMLElement, using the innerText property and the truncated text.

Update your code to include the following assignment to desc.innerText.

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + "...";
  }

  desc.innerText = content;
}
Now, once the page loads, you'll see that the description of each park is less than or equal to 250 characters, plus the ellipses.

**** The innerHTML property
What if you wanted the ellipses that you added above to be clickable? You can wrap an ellipsis in <a> tags to make it into a link. Now, update the code above to use a link instead of a plain string, as follows:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + '<a href="#">...</a>';
  }

  desc.innerText = content;
}
Now, when you look at the resulting page, you can see that the browser didn't interpret the additional content as HTML at all. Rather, it displayed the string that was added literally, exactly as you wrote it. You can also see this in the image below:

Biscayne National Park
That literal interpretation isn't a good experience for the users. If you want the browser to interpret the string that you provide as HTML, use the innerHTML property. The innerHTML property represents the HTML markup contained inside of an element.

You can modify line 9 in the code above to use the innerHTML property instead of the innerText property, like so:

for (let desc of descriptions.values()) {
  let content = desc.innerText;

  if (content.length > 250) {
    content = content.slice(0, 250);
    content = content + '<a href="#">...</a>';
  }

  desc.innerHTML = content;
}
**** Changing the style
To change the CSS style of an element, you can use the element's style property. This property is used to get and set the inline styles of an element. This style property is an object representing all of the CSS styles associated with an element. You can use this object to set any style that you wish.

Suppose that you wanted to bold any rating value that is greater than 4.7. You would have to select all rating values, check if they match the condition, and add a style to those that do. You can start by selecting all rating values, as follows:

const ratings = document.querySelectorAll(".rating-display .value");
Next, iterate through the list and get each actual rating value using the innerText property. This returns a string value, but you want to work with the rating as a number. So, use the parseFloat() method to convert a string into a floating point number, as shown below:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);
  console.log(ratingValue);
}
Next, check the condition. If ratingValue > 4.7, then set the fontWeight style to bold, like this:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.style.fontWeight = "bold";
  }
}
The name of the JavaScript property relates to the name of the CSS property. In CSS, a hyphen - is used in property names such as font-weight or background-color. But in JavaScript, the hyphen is dropped, and camelCase is used to create the property name. In other words, property names in JavaScript look like fontWeight or backgroundColor.

Here's another example of a modified style property. The following code sets the color of the rating text to a lighter green if the rating is greater than 4.7.

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.style.fontWeight = "bold";
    rating.style.color = "#3ba17c";
  }
}
A complete list of the CSS style properties and the corresponding JavaScript names for those styles may be found in MDN's CSS Properties Reference.

**** The classList property
Alternatively, if you want to make many changes to the style of an element, you could create a CSS class for that style. You could then add or remove that class from the element using the classList property.

The classList property is a list of the classes that are applied to an element. It provides methods to add() and remove() classes.

**** Do this
Dynamically add classes
Add the following CSS class rule to the style.css file.

.high-rating {
  color: #3ba17c;
  font-size: 1.5rem;
  font-weight: bold;
  text-shadow: 1px 1px rgba(0, 0, 0, 0.2);
  text-align: center;
}
When the rating is greater than 4.7, you want to replace the value class with the high-rating class. Modify the JavaScript code to do this, as follows:

for (let rating of ratings) {
  let ratingValue = parseFloat(rating.innerText);

  if (ratingValue > 4.7) {
    rating.classList.add("high-rating");
    rating.classList.remove("value");
  }
}
**** Creating DOM elements
In the examples above, you saw that you can add to the DOM using the innerHTML property of an element. Below is another example of creating new elements, using the createElement() method. The createElement() method creates a new element with the given tag name.

After creating an element, you will want to add the element to the page using the appendChild() method. This method adds a given element to the end of the list of children of a parent element.

**** Do this
Create a new element with text
Suppose that you wanted to dynamically add a statement to the page's heading, stating the number of parks on display. To do this, you would start by selecting all the parks on the page and getting the number of parks from that list. Then you would construct an element with this information and insert it on the DOM at the right place. Work through this process step by step below.

First, select the parks on the page using the park class as a selector:

const parks = document.querySelectorAll(".park-display");
Then, get the number of parks using the length property of the list:

const numberParks = parks.length;
Next, create a new element. In this case, you should use a <div>:

const newElement = document.createElement("div");
This creates an empty element. But, you have access to all the properties and methods that were used above to modify an element. You can set the text of this element with the innerText property, like this:

newElement.innerText = `${numberParks} exciting parks to visit`;
Add style and classes
You can also style this new element with either the style property or the classList property. Create a new CSS rule for the class header-statement in the style.css file, as shown below. Feel free to add any style that you wish.

.header-statement {
  color: #ffffff;
  font-size: 1.2rem;
}
Then add this class to the new element, as follows:

newElement.classList.add("header-statement");
Add the element to the page
Finally, to add the new element to the DOM, select the <header> element and use the appendChild() method to add the new element to the <header>, as shown below.

const header = document.querySelector("header");
header.appendChild(newElement);
**** Removing DOM elements
You can remove elements from the DOM via the removeChild() method, which removes the provided node from the DOM.

For example, you can select the first park on the page and remove it, as demonstrated here:

// Get the parent element of all parks
const main = document.querySelector("main");

// Select a single park
const park = main.querySelector(".park-display");

// Remove that park
main.removeChild(park);

*** 20.5

**** Event
When a web page is loaded in your browser, it basically sits there doing nothing, waiting for you to read it. As you start to read, you may attempt to scroll to view more of the page, or you may see links and buttons that invite you to click. As you move your mouse pointer around, the page starts to respond. You may see menus open, or animations start, or annoying ads pop up.

These actions, which are called events, all occur in response to some action that you are taking. An event is an action or occurrence that happens in the browser. The system fires an event when certain actions occur.

Key Term
Event: An action or occurrence that happens in the browser

There are many different types of events that occur in the browser. Here are some examples:

Mouse movement, clicks, or dragging

Typing on the keyboard

Touching and swiping on a touch screen device

Resizing the browser window

Closing the browser window or tab

Submitting a form

The web page finishing loading

To learn more about the many types of events that occur in the browser, check out MDN's Events page.

You can respond to these events by writing a function that will run when the event fires. These functions are called event handlers.

Key Term
Event handler: A function that is executed in response to an event occurring

**** Event listeners
When you create an event handler, you need to associate it with an element in the DOM. For example, the user may click a button. You then register an event handler on the button to run when the button's click event fires. The mechanism that detects the event is called an event listener. An event listener contains an event name and an event handler. When the event fires, the event handler is executed.

Key Term
Event listener: A mechanism that detects an event and contains an event name and an event handler

To create event listeners, use the addEventListener() method. This method takes two arguments: the name of the event and an event handler.

Using the National Parks repository, you can add some event listeners to the page.

**** Do this
Add event listener to a button
First, select a button on the page. Write the following code in the index.js file.

const firstBtn = document.querySelector("button");
Then call the addEventListener() method on this button. For now, you will write a very simple function for the event handler:

firstBtn.addEventListener("click", (event) => {
  console.log("You clicked the button", event);
});
Reload the page in the browser, and try clicking the first button on the page. The event handler accepts a single parameter representing an event object. This event object encapsulates some details about the event that occurred. Observe the output in the console.

**** Details about the event
The event object that is passed to the event handler contains some information that you can use while handling the event. The event object is automatically passed to event handlers when they are invoked. They contain information relevant to the event itself.

For example, you can get the specific element that fired the event with the target property of the event object, as shown here:

firstBtn.addEventListener("click", (event) => {
  console.log(event.target);
});
This is especially useful when you attach the same handler to multiple elements. For example, you may want to highlight a park when the button associated with that park is clicked. You could attach the same event handler to each of these buttons. Take a look:

// Select all the buttons for all the parks
const allBtns = document.querySelectorAll(".rate-button");

// Iterate through the list of buttons and add an event handler to each
allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    console.log(event.target);
  });
});
Notice that when you click any of the buttons, you get the same result. So how would you know which park belongs to the button that was clicked?

The <section> element that represents a park is the parent of the button. Because event.target refers to the button that was clicked, then using the parentNode property of that button will get you the <section> element that was clicked. Here's what that looks like:

allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    console.log(event.target.parentNode);
  });
});
Notice that each time you click the button, the <section> element in which that button resides is logged to the console. You can then manipulate this element in any way that you wish. For example, the following code changes the background color:

allBtns.forEach((btn) => {
  btn.addEventListener("click", (event) => {
    const park = event.target.parentNode;
    park.style.backgroundColor = "#c8e6c9";
  });
});
**** A complete example
Suppose that you wanted to give the user the ability to sort the list of parks displayed on the page; you want them to be able to sort by either name or rating. You can add two links and allow the user to click whichever one they wish. You would then get the list of parks from the DOM, perform a sort on the list, and insert the parks back into the DOM in the new order.

Start by adding the following HTML to index.html. Insert this between the <header> and the <main>.

<div class="sorter">
  Sort by:
  <a href="" class="sort-link" id="name-sorter">Name</a> |
  <a href="" class="sort-link" id="rating-sorter">Rating</a>
</div>
Then, optionally, you could add some CSS to the style.css file.

.sorter {
  width: 90%;
  margin: 0 auto;
  padding: 6px;
}
Next, add an event listener to the link. You will build this in steps so that it is clear what each step does. The following code all goes in the index.js file.

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", (event) => {
  console.log("You clicked the name sorter");
});
Notice that you are selecting the link by the ID. However, when you click the link, the log in the console blinks for a moment and then disappears. Why is that?

The default behavior of a link is to follow the link that was clicked. In this case, the browser is simply reloading the page. That clearly isn't what you want. You can stop this from happening using the preventDefault() method of the event object:

nameSorter.addEventListener("click", (event) => {
  event.preventDefault();
  console.log("You clicked the name sorter");
});
This time, when you click the link, the page doesn't reload. Here is the logic that you will implement in this event handler:

Get the <main> element that contains all the parks.

Get a NodeList of all the parks.

Empty the <main> element.

Convert the NodeList to an array for convenience of sorting.

Sort the array using techniques that you learned previously.

Iterate through the sorted array and append each park to <main>.

Remember, you'll build the event handler step by step. Start by reviewing the code for the first three steps:

nameSorter.addEventListener("click", (event) => {
  event.preventDefault();

  // 1.  Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main element
  main.innerHTML = "";
});
If you run the above code, you will notice that the parks disappear from the page when the link is clicked. That is because you removed them from the DOM. However, they still exist and can be referenced from the parksList variable.

To create an array from the NodeList, use the Array.from() method, as shown below. This takes an array-like structure and constructs an array.

// 4. Create an array
const parksArray = Array.from(parksList);
You can now use the sort() method of the array to sort this array. However, you need to write the function that defines how to sort the parks. Given two park elements, you need to find the name of each park and then compare the names. The park names are the innerText of the <h2> element.

// 5. Sort the array
parksArray.sort((parkA, parkB) => {
  const parkAName = parkA.querySelector("h2").innerText;
  const parkBName = parkB.querySelector("h2").innerText;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
});
The final step is to iterate over this sorted array and append each park element to the <main> element.

So, the full code may look like this:

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", (event) => {
  event.preventDefault();

  // 1. Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main element
  main.innerHTML = "";

  // 4. Create an array
  const parksArray = Array.from(parksList);

  // 5. Sort the array
  parksArray.sort((parkA, parkB) => {
    const parkAName = parkA.querySelector("h2").innerText;
    const parkBName = parkB.querySelector("h2").innerText;
    if (parkAName < parkBName) {
      return -1;
    } else if (parkAName > parkBName) {
      return 1;
    } else {
      return 0;
    }
  });

  // 6. Insert each park into the DOM
  parksArray.forEach((park) => {
    main.appendChild(park);
  });
});
As you can see, the event handler code has gotten quite long. To help make the code more manageable, you can refactor this code by creating an external function for the event handler, and another for the sorting. The following code is equivalent to the above.

// Function for sorting by name
const sortByName = (parkA, parkB) => {
  const parkAName = parkA.querySelector("h2").innerText;
  const parkBName = parkB.querySelector("h2").innerText;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
};

// Function for handling the `nameSorter` click
const nameSorterClickHandler = (event) => {
  event.preventDefault();

  // 1.  Get the main element
  const main = document.querySelector("main");

  // 2. Get the list of parks
  const parksList = main.querySelectorAll(".park-display");

  // 3. Empty the main
  main.innerHTML = "";

  // 4. Create an array
  const parksArray = Array.from(parksList);

  // 5. Sort the array
  parksArray.sort(sortByName);

  // 6. Insert each park into the DOM
  parksArray.forEach((park) => {
    main.appendChild(park);
  });
};

// Select the `nameSorter` link
const nameSorter = document.querySelector("#name-sorter");

// Add an event listener
nameSorter.addEventListener("click", nameSorterClickHandler);
**** Do this
Sort parks by rating
Implement an event handler for the ratingSorter link. Use the above example as a template.

**** The DOMContentLoaded event
So far, you have been writing the JavaScript code to interact with the DOM without regard to whether the DOM has been fully loaded by the browser. In this fairly small web page that you are using as an example, this hardly matters. But what happens when the web page becomes much larger, and the browser has a lot more work to do to render the page? Is it guaranteed that the JavaScript code will run only after the HTML is fully parsed and loaded by the browser? The short answer is no.

Therefore, you need some way of knowing that the DOM is ready for you to interact with it. Luckily, there is a built-in event that you can hook into. Once the HTML is fully parsed and loaded, the browser fires an event called DOMContentLoaded. The DOMContentLoaded event fires when the HTML is fully parsed and loaded, whether or not the stylesheets and images are done loading.

To make sure that your HTML has been loaded into the DOM before your JavaScript code tries to interact with the DOM, you can run your JavaScript code when the DOMContentLoaded event fires. This event is attached to the window object, which you can think of as the browser itself.

**** Do this
Add a DOMContentLoaded event handler
Add the following code to the JavaScript file, reload the page in the browser, and observe the console.

console.log("Before!");

window.addEventListener("DOMContentLoaded", (event) => {
  console.log("Loaded!");
});

console.log("After!");
You will see output similar to this:

Before!
After!
Loaded!
The code in the JavaScript file executes immediately as the file is parsed. However, the code inside the DOMContentLoaded event handler doesn't run until the HTML is fully parsed and loaded into the DOM.

**** Refactor the DOM manipulation code
It is common practice to move code that manipulates the DOM into a single DOMContentLoaded event-handler function. You can name that function anything that you want. For example, you might name it init, ready, or main, as in the example below. Notice how main is declared, then passed to window.addEventListener() as the event handler:

// Declare handler and support functions here

// Function for sorting by name
const sortByName = ...

// Function for sorting by rating
const sortByRating = ...

// Function for handling the `nameSorter` click
const nameSorterClickHandler = ...

// Function to handle the `ratingSorter` click
const ratingSorterClickHandler = ...


// The code that runs once the DOM is loaded
const main = () => {
  // Select the `nameSorter` link
  const nameSorter = document.querySelector("#name-sorter");

  // Add an event listener
  nameSorter.addEventListener("click", nameSorterClickHandler);

  // Select the `ratingSorter` link
  const ratingSorter = document.querySelector("#rating-sorter");

  // Add an event listener
  ratingSorter.addEventListener("click", ratingSorterClickHandler);
}

// Add event listener for `DOMContentLoaded`
window.addEventListener("DOMContentLoaded", main);

*** 20.6

Websites often capture data entered by users. The user enters data on the form and then submits it. At this point, some validation is typically performed. So, you need to write some code to handle the event of the form being submitted.

The submit event fires when the user submits a form. This event fires on the <form> element itself, not on any button on the form.

As you did with other events, you can simply provide a handler function for the submit event.

Starter code
You will use the same code repository that you used in the previous lessons. The starter code for this lesson is in the branch Form_Starter.

If you need to clone the repository, run the following command in the terminal.

git clone https://github.com/Thinkful-Ed/starter-national-parks.git
Once the repository is cloned to your local machine (or if you had it already), navigate to the project folder and check out the branch.

git checkout Form_Starter
Examine the index.html file. There is a <form> for adding a new park, with inputs for the various park values.

Handling the submit event
To handle the form submission, you need an event handler function. You then create the event listener on the form. As you did in the previous lesson, you will perform this when the DOM is fully loaded.

Do this
Create a submit handler
In the index.js file, create a function named submitHandler(). This function will be used for handling the form submission.

const submitHandler = (event) => {
  console.log("The form was submitted");
};
Then add a main() function that creates the event listener for the form submission.

const main = () => {
  // Get the form element
  const form = document.querySelector("#park-form");

  // Attach the submit handler
  form.addEventListener("submit", submitHandler);
};
And finally, add an event listener for DOMContentLoaded that invokes the main() function.

window.addEventListener("DOMContentLoaded", main);
You will notice that when you try to submit the form, the page is reloaded immediately. That is the default behavior of forms in a browser. You can stop this default behavior using the preventDefault() method of the event. Modify the submitHandler() function with this statement:

const submitHandler = (event) => {
  event.preventDefault();
  console.log("The form was submitted");
};
You will notice that upon submitting the form, the page no longer refreshes.

The FormData object
Now that you have a handler that is invoked on a form submit, you need to get the data that the user entered on the form. There are a number of ways that you could do this.

You could directly select one of the <input> elements and use the value property to get data. To do this, you would add the following to the submitHandler() function:

// Get the name input
const parkName = document.querySelector("#name-input").value;

console.log(parkName);
Now, when you enter a name and submit the form, you'll see that value.

However, remember that there's more than one way to get the data. In fact, there is a built-in object that can automatically read the data from the form and present it in an easy-to-use interface. The FormData object can be populated with a form's data as a set of key-value pairs. To use the FormData object, simply instantiate one with the <form> element, as shown below.

const submitHandler = (event) => {
  event.preventDefault();

  const formData = new FormData(event.target);
};
The FormData object has several methods for working with the form. You can use the get() method to get a specific value. The keys in the FormData correspond to the names of the form's <input> elements.

For example, to get the park name value, you could use the following code:

const name = formData.get("name");
console.log(name);
Required validation
Before using the data entered by the user, you can do some validation on it. For now, you'll go through some basic required validation, just so that you can see that it is possible. You will notice that on the HTML form, there are some error messages that are currently hidden by the CSS.

You can validate that the user entered some text for each form input. And if they did not, you can display the corresponding error message. Since you will be using the same code to check each input encapsulating that logic in a function would make that easier.

Do this
Add validate function for required fields
Add the following function to the JavaScript file. It accepts a single string value and returns true if the value isn't null and the string contains at least one non-space character.

function validateExists(value) {
  return value && value.trim();
}
The main validation function
Placing all the code to perform the validation in its own function would be useful and make the code more readable. This function will take each input field, perform required validation on it, and generate a collection of error messages which may then be displayed for the user.

Here's an example of such a function. It performs the required validation on each of the fields on the form.

function validateForm(formData) {
  const errors = {};

  // Check if name was entered
  if (!validateExists(formData.get("name"))) {
    errors.name = "Please enter a name";
  }

  // Check if rating was entered
  if (!validateExists(formData.get("rating"))) {
    errors.rating = "Please enter a rating";
  }

  // Check if description was entered
  if (!validateExists(formData.get("description"))) {
    errors.description = "Please enter short description";
  }

  // Check if established date was entered
  if (!validateExists(formData.get("established"))) {
    errors.established = "Please enter date";
  }

  // Check if area was entered
  if (!validateExists(formData.get("area"))) {
    errors.area = "Please enter the area of the park";
  }

  // Check if location date was entered
  if (!validateExists(formData.get("location"))) {
    errors.location = "Please enter the location of the park";
  }

  return errors;
}
This function accepts a FormData object containing the data from the form and checks each one to ensure that some value was entered. Now, this function must be called from the submitHandler() function.

Do this
Validate the form
Add the validateForm() function to the JavaScript file then modify the submitHandler() function as follows.

const submitHandler = (event) => {
  event.preventDefault();

  const form = event.target;
  const formData = new FormData(form);

  const errors = validateForm(formData);

  // Clear all previous errors
  const errorElements = document.querySelectorAll(".error");
  for (let element of errorElements) {
    element.style.display = "none";
  }

  // Display any new errors
  Object.keys(errors).forEach((key) => {
    // Find the specific error element
    const errorElement = document.querySelector(`#${key}-form .error`);
    errorElement.innerHTML = errors[key];
    errorElement.style.display = "block";
  });
};
Of course, this is just a basic validation that is used for illustration. This could have been accomplished in a number of other ways.

For example, the ratings field is supposed to be a number in the range 1-5, inclusive. You can create validation functions to validate that a given value is actually a number and another that validates the number in a specific range.

function validateNumber(value) {
  return !isNaN(value);
}

function validateRange(value, min, max) {
  return value >= min && value <= max;
}
Then the validateForm() function may be modified to add these validations to the ratings.

  ...

  // Check if rating was entered
  if (!validateExists(formData.get("rating"))) {
    errors.rating = "Please enter a rating";
  } else {
    // Check if the rating is a number
    if (!validateNumber(formData.get("rating"))) {
      errors.rating = "Rating must be a number";
    } else {
      // Because it is a number, convert it
      const rating = Number.parseFloat(formData.get("rating"));
      // Check that the rating is between 1 and 5, inclusive
      if (!validateRange(rating, 1, 5)) {
        errors.rating = "Rating must be between 1 and 5 inclusive";
      }
    }
  }

  ...
Similarly, other validation for any constraints on the data may be implemented in this function.

Add a park
Finally, if all the validation passes, you could update the DOM with the new park information. This would involve creating a new element for the form, making sure that it is formatted the same way as all the other parks on the page, and appending it to the parent element of all the parks.

By observing the HTML, you can see that a park is constructed like this:

<section class="park-display">
  <h2>The park name here</h2>
  <div class="location-display">the park location here</div>
  <div class="description-display">The park description here</div>
  <button class="rate-button" title="Add to Favourites">&#9734;</button>
  <div class="stats">
    <div class="established-display stat">
      <h3>Established</h3>
      <div class="value">The date of establishment here</div>
    </div>
    <div class="area-display stat">
      <h3>Area</h3>
      <div class="value">The area of the park here</div>
    </div>
    <div class="rating-display stat">
      <h3>Rating</h3>
      <div class="value">The rating of the park here</div>
    </div>
  </div>
</section>
Most of this is just template data—that is, it's mostly parts that don't change, interspersed with some data to be filled in.

You can create a new <section> element and set the rest of the HTML as the innerHTML property of the new element. You can use template literals to construct the correct HTML.

Do this
Add a park to the DOM
Add the following code to the end of the submitHandler() function.

// If there are no errors
if (!Object.keys(errors).length) {
  // Create a new element
  const parkSection = document.createElement("section");

  // Add the park class
  parkSection.classList.add("park-display");

  // Construct the HTML for this element
  const content = `
    <h2>${formData.get("name")}</h2>
    <div class="location-display">${formData.get("location")}</div>
    <div class="description-display">${formData.get("description")}</div>
    <button class="rate-button" title="Add to Favourites">&#9734;</button>
    <div class="stats">
      <div class="established-display stat">
        <h3>Established</h3>
        <div class="value">${moment(formData.get("established")).format(
          "MMMM D, YYYY"
        )}</div>
      </div>
      <div class="area-display stat">
        <h3>Area</h3>
        <div class="value">${formData.get("area")}</div>
      </div>
      <div class="rating-display stat">
        <h3>Rating</h3>
        <div class="value">${formData.get("rating")}</div>
      </div>
    </div>
    `;

  // Set the innerHTML
  parkSection.innerHTML = content;

  // Append to the main element
  document.querySelector("main").appendChild(parkSection);
}
The Moment library, which is included in the index.html file, can help you format dates before displaying them in the DOM.

In the content HTML above, calling moment(formData.get("established")).format("MMMM D, YYYY") will format any valid date entered into the established field using the MMMM D, YYYY format (which looks like January 1, 1999).

For example, if you enter a valid date such as 12-06-1987 or 12/06/1987 into the established field and submit the form, the date will show up as December 6, 1987 in the DOM. Using the moment library to format dates in your website can therefore help you display dates in a consistent manner in the DOM, regardless of the user input (as long as it's a valid date).

Check out the Moment.js docs for other arguments that you can pass to the moment().format() method to control how dates are displayed in the DOM. Also check out how you can use the Moment library to verify a date's validity.

The full solution code for this lesson can be found in the Form_Solution branch on the starter repository.

*** 20.7

Key Terms
Event delegation
The process of handling events at a higher point in the DOM than where the event originated
Starter code
For this lesson, you will be using the same repository as in the previous lessons in this module.

If you haven't already done so, clone the repository to your local machine as follows:

git clone https://github.com/Thinkful-Ed/starter-national-parks.git
The starter code is in the branch Render_Starter. Check out that branch using the command below, and load the index.html file in the browser.

git checkout Render_Starter
Data and the DOM
In the code that you have written so far, the data associated with the parks has all been contained in the HTML file. As a result, the structure of the HTML has become tightly coupled to the processing of the data.

For example, look at the way that the parks are sorted by rating. Here is the sortByRating() function used to perform the sort.

const sortByRating = (parkA, parkB) => {
  const parkARating = parseFloat(
    parkA.querySelector(".rating-display > .value").innerText
  );
  const parkBRating = parseFloat(
    parkB.querySelector(".rating-display > .value").innerText
  );
  return parkBRating - parkARating;
};
In particular, pay attention to the way that you got the rating value from the DOM. You selected an element with the class rating and looked for a direct descendant with the class value. This can be problematic for a number of reasons.

If the HTML structure is updated for any reason—such as to improve the layout or to add further data to the park—the JavaScript sorting code will break.

And if the style is updated and the class names are changed, that will also break the JavaScript code. For that reason, you can say that the HTML structure is tightly coupled to the JavaScript code. This coupling can make it very difficult to maintain code in the long run.

So how can you make the HTML and JavaScript files less dependent on each other? One way is to identify the data that you are concerned with and store that data separately. You can then generate the DOM based on the data.

The data
In the starter code, there is a file named data.js. This file contains a single array declaration, and the array contains several objects representing parks.

const parks = [
  {
    name: "Biscayne National Park",
    location: "Florida, United States",
    description:
      "Biscayne National Park encompasses coral reefs, islands and shoreline mangrove forest in the northern Florida Keys. Its reefs and islands are accessible only by boat. Dolphins, turtles and pelicans live in Biscayne Bay Lagoon. The underwater Maritime Heritage Trail links dive sites, most of them shipwrecks. On Boca Chita Key, Boca Chita Lighthouse has coastal views. A museum at Convoy Point explains local ecosystems.",
    established: "June 28, 1980",
    area: "172,971 acres (699.99 km^2)",
    rating: 4.7,
  },
  // ...
];
You can now write a function whose job it is to construct a DOM element for each park and insert it into the DOM at an appropriate place. If you update this data at any time, say in response to the user adding a new park, you can simply run the function again to update the DOM.

Similarly, if you want to sort the data, you can perform the sort on this array of data, and then execute the same function again to update the DOM with the sorted data.

When you generate the DOM in response to data in this way, you are rendering the user interface. For that reason, it makes sense to name this function render().

The render() function
To render the parks on the page, you will have to do the following:

Remove any existing content from the parent element.

Create the HTML for each park in the array.

Set the innerHTML of the parent element.

Do this
Create a renderOnePark() function
You can create a function named renderOnePark() that accepts a park and returns the HTML code for that park. To do so, add the following code to the index.js file.

const renderOnePark = (park) => {
  // Get the individual properties of the park
  const { name, location, description, established, area, rating } = park;

  const content = `
      <section class="park-display">
        <h2>${name}</h2>
        <div class="location-display">${location}</div>
        <div class="description-display">${description}</div>
        <button class="rate-button" title="Add to Favourites">&#9734;</button>
        <div class="stats">
          <div class="established-display stat">
            <h3>Established</h3>
            <div class="value">${established}</div>
          </div>
          <div class="area-display stat">
            <h3>Area</h3>
            <div class="value">${area}</div>
          </div>
          <div class="rating-display stat">
            <h3>Rating</h3>
            <div class="value">${rating}</div>
          </div>
        </div>
      </section>
  `;
  return content;
};
Create a render() function
The render() function will make use of the renderOnePark() function. Add the following code to the index.js file.

const render = () => {
  // Get the parent element
  const main = document.querySelector("main");

  // Empty the parent element
  main.innerHTML = "";

  // Get the parks HTML
  const content = parks.map(renderOnePark).join("");

  // Set the `innerHTML` of parent element
  main.innerHTML = content;
};
Call render() in the main() function
To call the render() function, add the following statement to the main() function.

const main = () => {
  // All the existing code

  render();
};
Refactor the sort
The two sort functions are still getting the data from the DOM. You can refactor these to directly sort the parks array itself and simply call render() when it is time to update the DOM.

The sortByName() function may be refactored to accept two park objects rather than two DOM elements.

const sortByName = (parkA, parkB) => {
  const parkAName = parkA.name;
  const parkBName = parkB.name;
  if (parkAName < parkBName) {
    return -1;
  } else if (parkAName > parkBName) {
    return 1;
  } else {
    return 0;
  }
};
Notice that you aren't querying the DOM anymore. You have direct access to the data. Correspondingly, the nameSorterClickHandler() function is now simpler. You can remove all the DOM access and manipulation. You just need to do two things:

Sort the array.

Render the page.

You can implement this as follows:

const nameSorterClickHandler = (event) => {
  event.preventDefault();

  parks.sort(sortByName);

  render();
};
Do this
Refactor the sort-by-rating functions
Using the above as a guide, refactor the sort-by-rating functions to use the render() function.

Adding new park
In the previous lesson, you added a new park by constructing the DOM element for the new park and appending it to the DOM. Now that you have separated the data from the DOM, you should instead insert a new park object into the parks array, and then render the page again.

You can modify the submitHandler() function to do this. Change the function as follows:

const submitHandler = (event) => {
  event.preventDefault();

  const form = document.querySelector("#park-form");
  const formData = new FormData(form);

  // Keep track of if any errors are found
  let hasErrors = false;

  // Validation code skipped for brevity
  // ...

  // If there are no errors
  if (!hasErrors) {
    // Create an empty object
    const park = {
      name: formData.get("name"),
      location: formData.get("location"),
      description: formData.get("description"),
      established: formData.get("established"),
      area: formData.get("area"),
      rating: formData.get("rating"),
    };

    parks.push(park);

    render();
  }
};
The favorite buttons
You may have noticed that now that you have refactored the code, the favorite buttons no longer work. This is because you are losing the event listeners associated with the button. Remember that the main function runs as soon as the DOM is loaded for the first time.

In the main function, all the buttons on the page are selected, and an event listener is attached to each one. However, you consequently remove that content from the DOM any time that you call the render() function. When you remove an element from the DOM, all associated event listeners are also removed.

But what if you instead attached the event listener to an element that remains on the page all the time? For example, what if you attached it to the <main> element? Because that element is never removed, if you attach an event listener, then it stays for the lifetime of the page.

Consider the following diagram:

The way a click event propagates up the DOM
This diagram shows how a button is positioned on top of the section, which is positioned on top of the main, which in turn is positioned on top of the body. Even though the mouse pointer is over the button, it is also over each of these elements in turn.

When you click the button, the click event propagates up the DOM from the button, to the section, to the main, and to the body.

You can modify the main() function by removing the event-handling code for the buttons and replacing it with this:

// Select all the buttons for all the parks
const main = document.querySelector("main");

// Add event handler to the main
main.addEventListener("click", favoriteButtonClickHandler);
Then you need to modify the favoriteButtonClickHandler() function. Because you attached the event listener to the <main> element, it triggers whenever a click happens anywhere on the <main>. You want to restrict the event handling to only the buttons.

You can do a conditional check to ensure that the element that triggered the event was the button.

Modify the favoriteButtonClickHandler() function as follows:

const favoriteButtonClickHandler = (event) => {
  if (event.target && event.target.nodeName == "BUTTON") {
    const park = event.target.parentNode;
    park.style.backgroundColor = "#c8e6c9";
  }
};
Here, you are checking that the target of the event—the actual element that was clicked—is a button. If so, you perform the action.

This way of handling events is called event delegation. Event delegation is the process of handling events at a higher point in the DOM than where the event originated. It's said that the event propagates up the DOM.

If you want, you can continue working on this application to improve it even further. But now, you're familiar with the essentials of interacting with the DOM, handling events, and separating the data processing from the DOM.

** module 21 rendering with react
*** 21.1 Overview: Rendering with React

Overview: Rendering with React
9 minutesEstimated completion time
Overview

As you've likely seen, DOM manipulation code can quickly become overwhelming. Managing multiple event listeners and the changing state of the page can be difficult to do in a way that doesn't result in extremely complex code. So in this module, you'll learn how to use React, a powerful tool that makes it easier to build complex web applications that rely on DOM manipulation.

Various frontend frameworks have begun to arise as a way to manage the complexity of DOM manipulation code; these frameworks make it easier to build complex pages that rely heavily on DOM manipulation. AngularJS, Ember.js, Vue, and React are just some of the tools that have become popular.

React is by far the most popular of these. React's component structure allows for quickly building a complex web application that relies on DOM manipulation. In this module, you will get your first taste of React. By the end of the module, you'll be able to use React components to recreate the basic structure of a web page.

In some ways, this may feel like taking a step back. You'll be redoing tasks that you could achieve with basic HTML, CSS, and DOM manipulation. But as you'll see later, although React takes a bit of work to set up, it's powerful once you begin to build more complex applications.

*** 21.2 Create React App

Create React App
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to create, modify, and run a basic React app on your computer using the create-react-app command.
Overview

To get a React app running on your computer, you need to create numerous files. Fortunately, a script called Create React App will generate all of these files for you. In this lesson, you'll learn how to use Create React App to set up a React app.
Creating a React app

Start by watching the video below, which provides a brief introduction to the process for setting up a React app using the Create React App script. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.

Use npx to run the create-react-app command. This command takes a folder name as an argument and will create the folder for you.

The full command will look something like this:

npx create-react-app <folder-name>

Do this
Create a React application

Navigate to a folder that isn't a Git repository. Then, run the following command:

npx create-react-app getting-started-with-react

If you inspect the directory, you'll see that a new folder, getting-started-with-react, has been created. From the command line, navigate into that folder.
Running the application

The package.json file inside of the newly created React application comes with a few useful scripts. One of these scripts is the following:

npm start

Once you run the command above, you'll see something like the following output in your terminal:

Compiled successfully!


You can now view getting-started-with-react in the browser.


  Local:            http://localhost:3000

  On Your Network:  http://XX.X.X.XX:3000


Note that the development build is not optimized.

To create a production build, use npm run build.

If your browser doesn't open automatically, open the browser to the following page:

http://localhost:3000

This is where your app is hosted on your machine. You will see a spinning blue React logo. This is the default app that Create React App starts with, but you will edit it to be your own.
What's happening on your command line?

You don't have access to the command-line prompt when the local server is running.

This is because when npm start is run, a package called webpack spins up a server to host your frontend code. This server will keep running so that you can witness changes made to your application while you're working on it, and it will provide feedback when any errors occur.

If you need your command line for something else, open a new tab in your terminal application.

If you need to stop the server, with the terminal window active, you can type Control+C (or Command+C on a Mac). You shouldn't stop a server by just closing the terminal tab where it's open; this won't always stop the server, and it will sometimes remain running in the background. Be intentional when running local servers, and close existing local servers before running new ones. If a local server is running and you try to run another one, you'll be offered the option of creating another port to run another local server, but that isn't recommended.

? Something is already running on port 3000. Probably:

  /usr/local/bin/node /Users/matthew/Desktop/www-2/reactx/node_modules/react-scripts/scripts/start.js (pid 8493)

  in /Users/matthew/Desktop/www-2/reactx


Would you like to run the app on another port instead? › (Y/n)

The video below provides an overview of this topic.
Do this
Stop and start the server

Practice stopping a running server by following the method outlined above. Then, restart the server by running npm start again. Once you get used to these commands, stopping and starting the server is quite easy.
Open up a new terminal tab

Open up a new terminal tab and navigate to the same getting-started-with-react directory. Continue any command-line work in this tab while the local server is running that application.
Standard files

The video below provides an overview of the standard Create React App files.

Create React App includes a few folders and several files:

    The files at the root level of this project typically include JavaScript configuration files like a package.json file and a README.md file. Make sure to update the README if this is a larger project!

    The public folder represents what is available to web browsers. This folder also contains the index.html file, which is the entry point to the application. During the build process, React inserts a script tag referencing the compiled code into the index.html file.

    The src folder is where most of your React components will be written. Only the files within this folder will be processed by React. This folder will commonly be used to also contain subdirectories for the files associated with each component, including images and CSS stylesheets.

You won't need all of these files to get started with React. At the start of any Create React App project, you can usually delete the following files:

    public/logo192.png: Smaller PNG of the React logo

    public/logo512.png: Larger PNG of the React logo

    src/logo.svg: SVG version of the React logo

    src/App.test.js: For tests that you aren't using

    src/reportWebVitals.js: For tests that you aren't using

    src/setupTests.js: For tests that you aren't using

Do this
Delete unneeded files

In your project, delete the unnecessary files listed above.

If you compile this code after deleting these files, you'll get an error in the terminal window running your local server.

Failed to compile.


Error: ENOENT: no such file or directory

Don't worry, as you update the existing JS files and remove the links to these recently deleted files, your projects will soon run error free.
How the files connect
The index.html file

The entry point to your application is index.html.

Within the <head> element, you can always update the <title>, which will display at the browser title. This is the only real change you may need to make to this page in getting started.

The <body> element will look similar to the code below:

<body>

  <noscript>You need to enable JavaScript to run this app.</noscript>

  <div id="root"></div>

  <!--

      This HTML file is a template.

      If you open it directly in the browser, you will see an empty page.


      You can add webfonts, meta tags, or analytics to this file.

      The build step will place the bundled scripts into the <body> tag.


      To begin the development, run `npm start` or `yarn start`.

      To create a production bundle, use `npm run build` or `yarn build`.

    -->

</body>

For now, just take note that the <div> element in the <body> is given the ID #root. As described in that code sample's comment, the build step will place the JavaScript that you write into this HTML container.

You don't need to make any additional changes to this HTML page, unless at some point you want to add HTML elements that are specific to this page and outside the React components that you plan to build.
The index.js file

The index.js file is your primary JavaScript file. The original demo code was the app with the spinning React logo that ran in your local server. For now, you'll be able to remove some of the original demo's unnecessary code to have a cleaner starting point for your own app.
Do this

Replace all of the default code within index.js with this code.

import React from "react";

import ReactDOM from "react-dom";

import "./index.css";

import App from "./App";


ReactDOM.render(

  <React.StrictMode>

    <App />

  </React.StrictMode>,

  document.getElementById("root")

);

In the index.js file, both React and ReactDOM are both imported. This use of import instead of require may be a little different than what you are used to. Importing React will make sure that your components are compiled properly, and ReactDOM will make sure that the DOM-related methods to display the components into the browser are also compiled properly.

Then, the CSS stylesheet index.css will be imported. This stylesheet should contain any global CSS styles that can be used within the web page and aren't specific to any component. The App.js file will then be imported. This file will contain your primary component that will be displayed in the web page.

React uses the render() function to display the component in the web page. The render() function takes two arguments: the React component to be rendered and the DOM container where it should be placed. The Create React App setup uses the root element as the DOM container, which is obtained with document.getElementById('root'). You can ignore the <React.StrictMode> tags for now because they enable more helpful warnings during development.

Note that when you save this file you'll still see errors because you still need to update the App.js file.
The App.js file

The App.js file is for your app component. It's the main component in React, and it acts as a container for all other components. You'll override the App component with your own code.

All of the code within the App component will be returned, exported, and then used within the index.js file as explained above.
Do this

Replace all of the default code within App.js with the following code.

import "./App.css";


function App() {

  return <h1>Hello World!</h1>;

}


export default App;

The first line in App.js will import the CSS stylesheet that should specifically be applied to the App component.

Then within your App component, create a simple component that has a heading with the following text: "Hello World!".

Notice that this code uses export default instead of module.exports to export the function. Although you don't need to use a named function, this can be useful for debugging purposes and for readability. These will be some of the little differences in the syntax when using React.

When you save this file, you will have fixed all the code that linked to your recently deleted files. In the browser that is displaying your local server, you will see a simple web page with a large text heading that displays "Hello World!".
Web page with a large text heading that displays "Hello World!"

If you closed the web browser, you can always reopen and view the local server using this URL:

http://localhost:3000

If your browser didn't reload with the latest changes, make sure that all of the changes that you have recently made to your pages have been saved. You can always try stopping and starting the local server, too.

*** 21.3 Thinking in React
Program overview

 Thinking in React
Lesson 3
Thinking in React
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to determine what React components should be created, given a web page design.
Overview

React apps are broken into pieces called components. As you'll see in this lesson, React allows you to define your own components, making it possible to split an application's code into easy-to-understand, reusable pieces.
Key Terms

Single-responsibility principle
    A principle that states that each module, function, or component in a program should have responsibility for one single part of the program

What is a component?

A component is a single part of the user interface and can be reused in multiple places. In general, components are made up of elements like <h1> or <img>, but with specific properties for your application. Although a component can be a single HTML element, it's typically a collection of elements.

Each component in the app has a single responsibility. For example, in a web page for a retail site, you may have these components:

    A menu bar

    The item listing, with a photo and description of the item

    A review, of which there may be multiple on the page

Note that you can customize each component for the app that you're working on.
Determining the components

Take a look at the following simple application, which keeps track of what the user needs to buy at the grocery store.
Shopping list app

There are a number of different pieces that make up this application:

    At the top, there is an input box for adding a new item to the list. This is its own component.

    The list is made up of any number of items and a title. The entire list is its own component.

    Each list item is also a component, nested inside of the overall list component. The checkbox and buttons are included in each list item component.

Here's a visual representation of this, with the three component types highlighted:
Shopping list app, annotated

At the top, highlighted in green, is the input box for adding an item. This is an AddItem component.

Below that, also highlighted in green, is the overall list. This is the GroceryList component. Inside of the GroceryList component are as many Item components as necessary to represent the list.

One of the Item components is highlighted in blue.
The single-responsibility principle

How should you decide what should be a component? The process is very similar to deciding what should be a function: you use the single-responsibility principle, which means that each component should have one thing that it does.

Consider what each of the components defined above do:

    The AddItem component is responsible for adding items to the list.

    The GroceryList component is responsible for showing a title and all of the items.

    Each Item component is responsible for showing information about the item, including whether it's been checked off or not.

Often, as an app grows and more functionality is added to the app, components are further broken down into more components.
Component composition

Components can be made up of other components. In this case, the entire application could be an App component that includes the following:

    One AddItem component

    One GroceryList component

    Any number of Item components, depending on the number of items in the list

There is a lot to learn about how to write components with React, but the first step to building any app is determining what components are needed.

*** 21.4 Import and export

Import and export
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use ES6 import and export statements.
Overview

When you work with React, you will be using special ES6 syntax for importing and exporting. As you'll see in this lesson, ES6 import and export statements work similarly to require() and module.exports, but they have a new and cleaner syntax.
Named exports

You will be using the keyword export to export objects from a file. To create and export a constant, you can use this syntax:

const website = "https://www.thinkful.com/";

export website;

You can also do this on one line, like so:

export const website = "https://www.thinkful.com/";

And you can have multiple named exports, as shown here:

export const website = "https://www.thinkful.com/";

export const username = "Bob";

Named imports

If you have a file constants.js, with website and username defined and exported, as they are above, you can use the import statement shown below. Note that you use an object with the variable names that are exported in constants.js.

import {website, username} from "./constants";

After running the import statement shown above, you'll have access to the website and username variables.
Default exports

When a file has a single export, or when one of the things exported will be used more often than others, you can set a default export instead of a named export.

The syntax for this is very similar to export statements, except that you add the keyword default.

const website = "https://www.thinkful.com/";

export default website;

Or, equivalently, you can write this in one line:

export default "https://www.thinkful.com/";

Now, you can import with the following statement:

import website from "./constants";

When using defaults, you don't need to give the exported variable the same name as the imported variable. You could also run the following import statement:

import url from "./constants";

For more information, check out the full MDN documentation on import and export.
Combining named and default exports

You can have one default export and any number of named exports. For example, the following file has a default and a named export.

export default const website = "https://www.thinkful.com/";

export const username = "Bob";

You can use the following import statement to import both website (a default export) and username (a named export).

import {website, username} from "./constants";

*** 21.5 Introduction to JSX

Introduction to JSX
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use React and JSX to make a basic web page.
Overview

In this lesson, you will learn the basics of JSX. JSX is an HTML-like syntax for defining user interface elements right inside your React code.
Starter code

Reuse the existing React App or create a new app following the steps in the Create React App lesson earlier in this module. Make sure that you remove the unnecessary files and update the existing files with the appropriate code.
Introduction to JSX in React

Start by watching the video below, which provides a brief introduction to this topic. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.

You've already seen JSX if you've used Create React App to generate a new React project.
Hello world in React

What you may have thought was HTML in your App.js file was actually JSX. That JSX element was written like this:

<h1>Hello World!</h1>

This JSX is written inside your JavaScript instead of in a separate HTML or template file. The complete code that you should be starting with in your App.js file should be as follows:

import "./App.css";


function App() {

  return <h1>Hello World!</h1>;

}


export default App;

Embedding JavaScript expressions in JSX

JSX is an expression, so you can save it to a variable and then return the value of that element, as shown here:

const element = <h1>Hello World!</h1>;

return element;

You can also embed JavaScript code into JSX by using curly braces {}, like this:

const name = "Alice";

const element = <h1>Hello {name}!</h1>;

return element;

Now, element will render as Hello Alice!.

You can put any JavaScript expression inside the curly braces. Here is an example using individual variables as well as the expression count * price. Notice that you can use parentheses () to enable all of these elements to take up multiple lines within this element.

const item = "apple";

const price = 2;

const count = 10;

const element = (

  <div>

    <h1>Total Purchased:</h1>

    <p>

      Purchased {count} {item}s for ${price} each. The total is ${count * price}

      .

    </p>

  </div>

);

return element;

Do this
Update your App.js file

Update your App.js file with the following code:

import "./App.css";


function App() {

  const element = <p>Hello, there!</p>;

  return element;

}


export default App;

As long as your local server is running, when you save this file, you should see your changes updated in the browser. Remember, when you export your code from App.js, it will be imported by index.js and then compiled within the index.html page. So, using separate files for each component simply makes this easier to keep organized as your code becomes more complex.
Use variables

Create a new variable called name, and feel free to assign it your own name. Then use it inside of your element variable. The end result of your code will look something like this:

import "./App.css";


function App() {

  const name = "Alice";

  const element = <p>Hello, {name}!</p>;


  return element;

}


export default App;

Save your file, and you'll see your new message within the browser.
Attributes

You can add attributes to JSX elements much like you can in HTML. For example, here's how you might create a link to the Thinkful home page using the attribute href:

<a href="https://www.thinkful.com/">Thinkful</a>

You can use variables in attributes as well. The code below, for example, stores the URL in one variable, the link text in another, and then creates a link tag.

function App() {

  const url = "https://www.thinkful.com/";

  const linkText = "Visit Thinkful";

  const element = <a href={url}>{linkText}</a>;


  return element;

}

Notice that you're using curly brackets {} around the url and linkText variables to insert them into the JSX expression.
Do this
Use a link

Now, create your own text links using the JSX element. Here's an example of how that might look:

const name = "Alice";

const url = "https://www.thinkful.com/";

const linkText = "Thinkful";

const element = (

  <p>

    {" "}

    Hey, {name}! Please visit <a href={url}>{linkText}</a>.

  </p>

);


return element;

Top-level JSX elements

The videos below provide overviews of parent elements and self-closing elements in React.

Note that a React component won't allow you to return more than one top-level JSX element. In other words, if you tried to return two top-level elements, as in the code below, you'd get an error when the file was saved and compiled.

const element = (

  <h1>Hello World!</h1>

  <h2>Have a good day.</h2>

);

return element;

The error when the code above is run would look similar to this:

Failed to compile.


SyntaxError: App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?

A simple solution is to create a single top-level JSX element that nests a number of elements, just as you would with HTML. Placing the two heading elements within a single <div> container follows the rules of JSX and allows you to add multiple JSX elements.

const element = (

  <div>

    <h1>Hello World!</h1>

    <h2>Have a good day.</h2>

  </div>

);

Or, if you want to avoid adding an unnecessary <div> container to the DOM, you can substitute the simple <div> container or a React fragment.

A React fragment is commonly written with short syntax, like this: <>...</>. It appears as empty tags (you may have noticed the suggestion in the error about using a JSX fragment <>...</>). Its sole purpose is to group elements that are next to each other. Using this is encouraged when you need to return multiple elements but you don't need a parent container, like a generic <div> container, to hold all the elements.

const element = (

  <>

    <h1>Hello World!</h1>

    <h2>Have a good day.</h2>

  </>

);

Do this
Create a React fragment

Create a JSX element that has multiple JSX elements of your choosing and is wrapped within a React fragment. It can be helpful to see what happens when it works, and it can also help to see the error message that displays when you have an error.

*** 21.6 Components and props
Components and props
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to define and render a functional component with props.
Overview

React components allow you to split your application into reusable pieces. You can create your own elements that are specific to your app. This enables you to factor the code into easy-to-understand pieces.
Key Terms

Functional component
    A JavaScript function that returns JSX
Prop
    An input passed into a React component as an object

Starter code

Reuse the existing React App or create a new app following the steps in the Create React App lesson earlier in this module. Make sure that you remove the unnecessary files and update the existing files with the appropriate code.
Defining components

The following video provides an overview of how to organize multiple React components. Start by watching the video, and then read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.

Although React allows you to define components with classes or functions, you have been using functional components in this module. A functional component is a function that returns JSX.

Here is an App component that displays a generic message in a <p> element:

function App() {

  return <p>Welcome back, valued customer!</p>;

}

You can render this component much like you would render any other element, as you already are doing in the index.js file when you are rendering this component:

<App />

As your App component gets more complex, you will find it helpful to break it up into smaller components. Rather than printing the welcome message within the App component, you could remove it and place that message into a new WelcomeBack component. And then within the App component, you can make use of the WelcomeBack component by calling it using <WelcomeBack />. This code provides the same outcome as before—it is just broken up into more than one functional component.

function WelcomeBack() {

  return <p>Welcome back, valued customer!</p>;

}


function App() {

  return <WelcomeBack />;

}

By wrapping your returned element in a React fragment and using parentheses () to contain the multiple lines of code, you can make use of the WelcomeBack component as often as you want within the App component.

function WelcomeBack() {

  return <p>Welcome back, valued customer!</p>;

}


function App() {

  return (

    <>

      <WelcomeBack />

      <WelcomeBack />

    </>

  );

}

Tip

Unlike vanilla JavaScript functions, React functional components begin with a capital letter (in the format WelcomeBack).
Do this
Create a new component

In your App.js file, include a WelcomeBack component with a message. Make use of it within the App component more than once.

import './App.css';


function WelcomeBack() {

  return <p>Welcome back, valued customer!</p>;

}


function App() {

  return (

    <WelcomeBack />

    <WelcomeBack />

  );

}


export default App;

You can return additional components from App as follows:

function WelcomeBack() {

  return <p>Welcome back, valued customer!</p>;

}


function EncouragingWords() {

  return <p>Believe you can and you’re halfway there.</p>;

}


function DailyTip() {

  return <p>Highlight a whole paragraph by triple-clicking on it.</p>;

}


function App() {

  return (

    <>

      <WelcomeBack />

      <WelcomeBack />

      <EncouragingWords />

      <DailyTip />

    </>

  );

}

Then, start the React application. You will see your WelcomeBack, EncouragingWords, and DailyTip components appear on the screen.

For the remainder of this lesson, you won't need the EncouragingWords and DailyTip components, so feel free to remove them from the App component and just keep the WelcomeBack components inside of App.

Then, with the React application running on your local server, you will see your WelcomeBack components appear on the screen. If you don't, make sure that you have your files saved, refresh your browser, and restart the application if necessary.

import React from "react";

import ReactDOM from "react-dom";

import App from "./App";


ReactDOM.render(

  <React.StrictMode>

    <App />

  </React.StrictMode>,

  document.getElementById("root")

);

Defining a component with props

The video below provides an introduction to using React components with props.

Generally, calling the same component multiple times doesn't provide much value, unless you make your components customizable. Components can take arguments, called props, which you can use to customize the element. Props are inputs passed into a React component as an object. They allow for data to flow from one component down to its children components.

Below, the WelcomeBack component is redefined so that it makes use of the props parameter. Take a look:

function WelcomeBack(props) {

  return <p>Welcome back, {props.name}!</p>;

}

When rendering the component, you can specify the value of the name prop as follows:

<WelcomeBack name="Joe" />

This will result in the following being rendered to the page:

<p>Welcome back, Joe!</p>

You can also use argument destructuring to further simplify the function, like so:

function WelcomeBack({ name }) {

  return <p>Welcome back, {name}!</p>;

}

Below, the WelcomeBack component is rendered twice, with a different value for name each time:

function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

      <WelcomeBack name="Anna" />

    </>

  );

}

This will result in the following being rendered to the page:

<p>Welcome back, Joe!</p>

<p>Welcome back, Anna!</p>

If no name property is passed in, then the component may look a bit odd, as shown below:

<WelcomeBack />

The above component will result in this:

<p>Welcome back, !</p>

So, in this case, you may want to set a default value for the property, like so:

function WelcomeBack({ name = "valued customer" }) {

  return <p>Welcome back, {name}!</p>;

}

Now, consider if you were to render this App component:

function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

      <WelcomeBack name="Anna" />

      <WelcomeBack />

    </>

  );

}

The above component would display in the browser like this:

Welcome back, Joe! Welcome back, Anna! Welcome back, valued customer!

As your code gets more complex, you can assign multiple props separated by a comma ,. If you wish, you can also assign default values to each of the props, like this:

function WelcomeBack({ name = "valued customer", adjective = "nice" }) {

  return (

    <p>

      Welcome back, {adjective} {name}!

    </p>

  );

}


function App() {

  return (

    <>

      <WelcomeBack name="Joe" adjective="funny" />

      <WelcomeBack name="Anna" adjective="clever" />

      <WelcomeBack />

    </>

  );

}

Do this
Customize the component

Update your WelcomeBack component to use props, as detailed above. Then, add the name property as well as any other properties that you want to add to your WelcomeBack component used in the App component.
Component composition

Components are often made up of other components. This is called component composition.

Take a look at the following App component, which renders the WelcomeBack component twice:

function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

      <WelcomeBack name="Anna" />

    </>

  );

}

In the code above, the App component returns an element (created within the <> fragments) with two components within it. Just like this App component, many of your components will have other components inside of them, too.
Component file structure

The video below provides an overview of how and why to separate React components into files.

As your components get more involved, it becomes important to break your code into multiple components. This makes your code more readable and easier to modify. It's standard to put each component in its own file; this makes it easier to navigate the code.

For the above example, where you have an App component that is composed of two WelcomeBack components, you could break the file up into two component files: App.js and WelcomeBack.js. And each JS file could have a corresponding CSS stylesheet that specifically styles the elements of that component. Typically, the CSS file will share the same name of the component to make it clearer which component the CSS file is supposed to be styling. You could even add Header and Footer components to this project.

Here is the full content of the four files:

// Header.js

import "./Header.css";


function Header() {

  return <h1>Header to the page.</h1>;

}


export default Header;

// WelcomeBack.js

import "./WelcomeBack.css";


function WelcomeBack({ name = "valued customer" }) {

  return <p>Welcome back, {name}!</p>;

}


export default WelcomeBack;

// Footer.js

import "./Footer.css";


function Footer() {

  return <h2>Footer to the page.</h2>;

}


export default Footer;

// App.js

import "./App.css";

import Header from "./Header";

import WelcomeBack from "./WelcomeBack";

import Footer from "./Footer";


function App() {

  return (

    <>

      <Header />

      <WelcomeBack name="Joe" />

      <WelcomeBack name="Anna" />

      <WelcomeBack />

      <Footer />

    </>

  );

}


export default App;

Note: You can also end your files with the .jsx extension instead of .js, and you may see both file extensions in this program. There is no difference between the two file extensions, although you should stick with one or the other in your own work.
Do this
Create a new file

Separate the WelcomeBack component into its own file, WelcomeBack.js. Follow the instructions above to connect the multiple files so that your work continues to show up. Feel free to add additional components, like Header and Footer, in their own files if you wish.

*** 21.7 Conditional rendering

Conditional rendering
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use if() and switch() statements to control the display of a component.
Overview

When you are working with direct DOM manipulation, you can set a message to only show if some condition is true. To accomplish that, you would need to check for that condition, and then hide or show elements based on the result. React is very similar. You can set your components to either display or not display, based on a value in JavaScript. In this lesson, you'll learn how to conditionally show certain elements to your users.
Starter code

Use the Create React App command-line program to create a new React application or reuse an existing React application. Give it a memorable name, like conditional-rendering. Then, follow the instructions in the Create React App lesson to remove unnecessary files.
The if() and switch() statements

Take a look at the Greeting component below, which takes language as a prop. It will display different text depending on the language.

// Greeting.js

function Greeting({ language }) {

  if (language === "es") {

    return <h1>Hola!</h1>;

  }

  return <h1>Hello!</h1>;

}

To see this difference in the app, you can use a Greeting component with the language as es (Spanish) and another Greeting component with no language specified (which defaults to English). Here's an example:

// App.js

function App() {

  return (

    <div>

      <Greeting language="es" />

      <Greeting />

    </div>

  );

}

You might prefer an inline if() statement in simple cases. Take a look:

// Greeting.js

function Greeting({ language }) {

  return <h1>{language === "es" ? "Hola" : "Hello"}!</h1>;

}

If you have more than two options, you can use a switch() statement, like this:

// Greeting.js

function Greeting({ language }) {

  switch (language) {

    case "es":

      return <h1>Hola!</h1>;

    case "fr":

      return <h1>Bonjour!</h1>;

    case "en":

    default:

      return <h1>Hello!</h1>;

  }

}

Do this
Create the Greeting component

Create a new Greeting component in its own file, Greeting.js. Include that component in the App.js file, and try setting up some conditionals so that you can see the difference.
Prevent rendering

Imagine that you are building an application that makes use of a number of notifications. If the user has notifications, you want to notify the user with a message. Otherwise, you want to display nothing.

With React, you can display nothing by returning null from a component, as shown here:

function Notifications({ notifications }) {

  if (notifications.length > 0) {

    return <p>You have {notifications.length} notifications today!</p>;

  }

  return null;

}


function App() {

  const notifications = ["You received a package", "The weather is sunny"];

  return <Notifications notifications={notifications} />;

}

Note that when the condition is relatively short, it can be useful to use the && operator instead of an if statement, as shown below. If the first value is true, the && operator will return the second value. If the first value is false, it will return the first value (false). When a component returns false, it renders nothing, just like it does if it returns null.

function Notifications({ notifications }) {

  return (

    notifications.length > 0 && (

      <p>You have {notifications.length} notifications today!</p>

    )

  );

}

*** 21.8 Lists and tables
Lists and tables
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will know how to use the map() method to display an array in a list or table.
Overview

Rendering lists and tables works slightly differently in React if those lists and tables are dependent on data. These differences aren't difficult to manage, but they're important to know about. This lesson will show you how to use lists and tables to create repeated elements in React.
Starter code

Use the Create React App command-line program to create a new React application or reuse an existing React application. Give it a memorable name, like lists-and-tables. Then, follow the instructions in the Create React App lesson to remove unnecessary files.
Lists

Imagine that you are creating an application that creates a grocery list for you. You may want to show your items in a list, like this:

<ul>

  <li>Bananas</li>

  <li>Apples</li>

  <li>Oranges</li>

</ul>

You may want to create this list based on an array, as shown below. This array may update or change based on the actions that you take in the application.

const groceryItems = ["Bananas", "Apples", "Oranges"];

You can use the map() method to create a <li> item for each item in groceryItems. Then, wrap it all with a <ul> tag. Take a look:

// GroceryList.js

function GroceryList({ items }) {

  return (

    <ul>

      {items.map((item) => (

        <li>{item}</li>

      ))}

    </ul>

  );

}

You can then use this component by passing groceryItems into it, like this:

<GroceryList items={groceryItems} />

This will lead to the same list that was originally shown—except now, you can easily change the list by updating the groceryItems array.
Rewriting lists

The code above is a bit complicated to read. Remember that JSX code can be assigned to a variable, like other JavaScript expressions. That means that the code below will work as well.

// GroceryList.js

function GroceryList({ items }) {

  const list = items.map((item) => <li>{item}</li>);

  return <ul>{list}</ul>;

}

There is no performance benefit to writing your code like this, but you may find it a bit easier to read.
Adding keys

If you look at the console for the above example, you will notice that you get a warning:

Warning: Each child in a list should have a unique 'key' prop.

React uses keys to help it update a list when the groceryList array changes. When you're creating a list, always give each list item a unique key. You can use item as the key if you know that it will be unique, but it is generally safer to use the list index or a unique ID.

So you can modify the code above as follows:

// GroceryList.js

function GroceryList({ items }) {

  const list = items.map((item, index) => <li key={index}>{item}</li>);

  return <ul>{list}</ul>;

}

Now, you can see that the warning message is gone.
Do this
Add a list

In your App.js file, create a todo array and include different to-do items inside of it. Then, render those items to a list in your App component.

An example solution is below. Try creating this on your own before looking at the solution!

import React from "react";


const todos = [

  "Finish the Lists & Tables checkpoint",

  "Clean my desk",

  "Make lunch",

];


function App() {

  const listItems = todos.map((todo, index) => <li key={index}>{todo}</li>);

  return <ul>{listItems}</ul>;

}


export default App;

Tables

Tables are useful for more complex information. For example, the grocery list created earlier could be built with more details, like this:

<table>

  <tr>

    <th>Quantity</th>

    <th>Item</th>

  </tr>

  <tr>

    <td>6</td>

    <td>Bananas</td>

  </tr>

  <tr>

    <td>3</td>

    <td>Apples</td>

  </tr>

  <tr>

    <td>10</td>

    <td>Oranges</td>

  </tr>

</table>

Instead of hardcoding the grocery list contents, you could have them stored like the array below:

const groceryList = [

  { quantity: 6, item: "Bananas" },

  { quantity: 3, item: "Apples" },

  { quantity: 10, item: "Oranges" },

];

When creating the table, you first add the header row, because that will be unchanged by the contents of groceryList. Then, you can use the map() method with groceryList to create a <tr> element for each row in the table. Like with lists, each row should have a unique key. Here's an example:

function GroceryList({ items }) {

  const rows = groceryList.map(({ quantity, item }, index) => (

    <tr key={index}>

      <td>{quantity}</td>

      <td>{item}</td>

    </tr>

  ));


  return (

    <table>

      <thead>

        <tr>

          <th>Quantity</th>

          <th>Item</th>

        </tr>

      </thead>

      <tbody>{rows}</tbody>

    </table>

  );

}

Do this
Update your to-do list

Update your todo array to be an array of objects with a description key and a completed key, like the example below:

const todos = [

  { completed: false, description: "Finish the Lists & Tables checkpoint" },

  { completed: false, description: "Clean my desk" },

  { completed: false, description: "Make lunch" },

];

Then, update your App.js to reflect the new data structure using a table. Try it out on your own at first, and then compare your work to the solution below.

import React from "react";


const todos = [

  { completed: false, description: "Finish the Lists & Tables checkpoint" },

  { completed: false, description: "Clean my desk" },

  { completed: false, description: "Make lunch" },

];


function App() {

  const rows = todos.map(({ completed, description }, index) => (

    <tr key={index}>

      <td>{description}</td>

      <td>{completed ? "Yes" : "No"}</td>

    </tr>

  ));


  return (

    <table>

      <thead>

        <tr>

          <th>Description</th>

          <th>Completed?</th>

        </tr>

      </thead>

      <tbody>{rows}</tbody>

    </table>

  );

}


export default App;

*** 21.9 Styling

Styling
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to style JSX with both external and inline CSS styles. You'll also be able to harness Bootstrap to improve your React presentations.
Overview

Working with CSS in React is very similar to working with CSS elsewhere. However, there are some particularities that are important to be aware of so that you can make the best use of your styles. So in this lesson, you'll explore the ins and outs of working with CSS in React.
Starter code

Reuse your existing React App. Or, if you wish, create a new app that follows all the steps listed in the Components and props lesson earlier in this module, following the instructions carefully in order to remove all unnecessary files and update the existing files with the code that you'll build on in this lesson.
Clearing your default CSS files

The existing CSS stylesheets that were originally created using the Create React App supplied various CSS rules in both the index.css and App.css files. Rather than explaining and updating all the prewritten styles, it's easier to simply delete all of the existing code in those two files.
Do this

Delete all the existing CSS styles from both the index.css and App.css files.
CSS Files with React

As explained in the Components and props lesson, as your application grows in size, it can help to break up each component. And when necessary, you may want to assign each component a corresponding CSS stylesheet with the same name to help identify the files that you'll also need to create.

// WelcomeBack.js

import "./WelcomeBack.css";


function WelcomeBack({ name = "valued customer" }) {

  return <p>Welcome back, {name}!</p>;

}


export default WelcomeBack;

// App.js

import "./App.css";

import WelcomeBack from "./WelcomeBack";


function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

    </>

  );

}


export default App;

// index.js

import React from "react";

import ReactDOM from "react-dom";

import "./index.css";

import App from "./App";


ReactDOM.render(

  <React.StrictMode>

    <App />

  </React.StrictMode>,

  document.getElementById("root")

);

In the above example, there are three JS files: index.js, App.js, and WelcomeBack.js. They each have a corresponding CSS stylesheet: index.css, App.css, and WelcomeBack.css, respectively. When the Create React App script created all of these files, the index.css and App.css were included. Because you manually created the WelcomeBack.js file, you also need to create the WelcomeBack.css file. And for each component file, consider adding the corresponding CSS file, too. This may seem like overkill at the moment because you don't have much content in the files, but this process can help reinforce your understanding of the relationships between all of these files.

Keep in mind that index.css is best used to contain all the global styles that affect the entire application. This includes all styles for general typography, including rules for the headings and paragraphs. The individual CSS files that have matching names to the components are necessary only when unique styles are needed for those particular components. If you aren't using unique styles for specific components, then you don't need to create and then link to empty CSS stylesheets for every component.
Adding CSS to external stylesheets

CSS works with JSX the same way that it does with HTML. When using CSS to target an element (like a p paragraph) or a class (like .username), you'll write the CSS within an external stylesheet exactly the same way that you would with HTML. Here are some examples:

/* WelcomeBack.css */

p {

  color: black;

  font-family: sans-serif;

}


.username {

  color: #fff;

  padding: 2px 4px;

  margin-right: 2px;

  background-color: #000;

  border-radius: 4px;

}

The first big difference in applying this CSS is that you cannot use a class attribute in JSX; you need to refer to that attribute as className. This is because class is a unique keyword in JavaScript. And because JSX is an extension of JS, using a class attribute can cause problems to occur when you compile your React app. Also, keep in mind that JSX always uses camelCase. So in JSX, the attribute is called className.

So, within the WelcomeBack.css file, the p style will be assigned to all paragraphs. When you want to apply the class .username, you can do so by applying it as className. And the <span> used in this example is just a simple JSX element; it's similar to a <div>, but it's an inline element—which means that it doesn't force the content onto a new line like a <div> container. That makes it perfect for styling a word or phrase within a paragraph slightly differently than the rest of the paragraph.

// WelcomeBack.js

import "./WelcomeBack.css";


function WelcomeBack({ name = "valued customer" }) {

  return (

    <p>

      Welcome back, <span className="username">{name}</span>!

    </p>

  );

}


export default WelcomeBack;

Inline styling

When you want to add specific styles to a particular element within a component and you don't feel that adding it to an external stylesheet is needed to help you keep your code organized, then you can add the CSS styles directly to the element within the component using inline styling.

To demonstrate an inline style added to the internal styles, the paragraph in the example below was wrapped within a <div> container. The <div> was then given specific styles that, in this case, probably wouldn't be applied anywhere else.

Note that there are also several small differences in how inline styles are written in JSX. The style attribute needs to be set to an object that contains the CSS properties that you want to set on the element. Within this object, two-word CSS properties need to be written in camelCase, like textAlign. And the values to the properties need to be passed as strings, so they need to be wrapped in quotation marks. Here's an example:

  return (

     <div style={{ border: "1px solid #000", textAlign: "center", borderRadius: "4px" }}>

       <p>Welcome back, {name}!</p>

     </div>

  )

}

If you have a few CSS rules, like in the WelcomeBack.css stylesheet that was imported into the WelcomeBack.js file earlier in this lesson, those rules can be applied to the JSX by storing the styles within variables and assigning the values of those variables to the inline styles. This is a great way to keep your inline styles more readable and organized.

Here is the WelcomeBack.js file updated with only inline styles:

// WelcomeBack.js

function WelcomeBack({ name = "valued customer" }) {

  const pStyle = {

    color: "black",

    fontFamily: "sans-serif",

  };

  const userName = {

    padding: "2px 4px",

    marginRight: "2px",

    backgroundColor: "#000",

    color: "#fff",

    borderRadius: "4px",

  };


  return (

    <p style={pStyle}>

      Welcome back, <span style={userName}>{name}</span>!

    </p>

  );

}


export default WelcomeBack;

Because the code in the WelcomeBack.js file isn't linked to the WelcomeBack.css stylesheet, the import link to that CSS stylesheet can be removed.

The variable names pStyle and userName can be any variable name that you want.

Again, when you add this code and save the file, you will see the same styles applied to your content as before. Only now, they'll be applied as inline styles.
Adding Bootstrap

Previously, if you wanted to include an external stylesheet, you would place a link to it in the <head> element of the HTML. You can do the same thing in React.

For example, if you wanted to add the Bootstrap CDN to your React application, you would go into the public directory and add the Bootstrap stylesheet <link> to the <head> element of the index.html file. Bootstrap would then be included for your entire project.

Remember that you must use className instead of the class attribute. That means that if you copy a component over from Bootstrap, you will need to change all occurrences of class to be className.

For example, you can use the .card and .card-body classes to render the card component like this:

<div className="card">

  <div className="card-body">This is some text within a card body.</div>

</div>

Do this

First, add the Bootstrap stylesheet <link> to the <head> element of the index.html file.

Next, create a new React component that primarily uses Bootstrap for styling. Here, you will use a Bootstrap card. Specifically, you should use the Quote option under the Header and footer section.

In the src folder, create a new file called Quote.js. Add the following code:

function Quote({ quote: { text, author } }) {

  return (

    <div className="card">

      <div className="card-header">Quote of the Day</div>

      <div className="card-body">

        <blockquote className="blockquote">

          <p>{text}</p>

          <footer className="blockquote-footer">{author}</footer>

        </blockquote>

      </div>

    </div>

  );

}


export default Quote;

The Quote component accepts a prop called quote, which is an object containing text and author properties. Here, their values are extracted into the text and author variables using destructuring. The component simply returns JSX.

Remember that you must use className instead of the class attribute when adding a class to a React component.

Next, in App.js, import the Quote component and use it within the App component, like this:

import "./App.css";

import WelcomeBack from "./WelcomeBack";

import Quote from "./Quote";


const quote = {

  text:

    "I am great believer in luck, and I find the harder I work, the more I have of it.",

  author: "Thomas Jefferson",

};


function App() {

  return (

    <>

      <WelcomeBack name="Joe" />

      <Quote quote={quote} />

    </>

  );

}


export default App;

The Quote component, which is styled with Bootstrap, is now displayed on the screen as follows:
Styled quote of the day

Note: If you need a refresher on other interesting features of Bootstrap, you can refer to the CSS frameworks module.
Adding Google Fonts

Google Fonts is a library of free and interesting font families that you can include in your project. There are several ways to incorporate Google Fonts into your project. One way is to include the <link> tag inside an HTML file, just like how you would include a regular stylesheet.
Do this
Add the Zen Dots font

Go ahead and add a font family called Zen Dots to the project. First, go to the Google Fonts website and look up Zen Dots using the search bar at the top-left corner of the page:
Zen Dots page on the Google Fonts web page

Click the Zen Dots card. Then, on the next page, click the + Select this style button:
Zen Dots page

A menu will slide out from the right. Under the Use on the web section, copy both of the provided <link> tags:
Use on the web options

The preconnect link tag speeds up the downloading of the font files, so it's important to include it.

In the index.html file within the public folder, paste the copied lines anywhere inside the <head> section.

Next, use the Zen Dots font family to style the paragraph tag inside the WelcomeBack component, like this:

function WelcomeBack({ name = "valued customer" }) {

  const pStyle = {

    color: "black",

-    fontFamily: "sans-serif",

+    fontFamily: "Zen Dots, cursive",

  };

  const userName = {

    padding: "2px 4px",

    marginRight: "2px",

    backgroundColor: "#000",

    color: "#fff",

    borderRadius: "4px",

  };


  return (

    <p style={pStyle}>

      Welcome back, <span style={userName}>{name}</span>!

    </p>

  );

}


export default WelcomeBack;

Note that you're using cursive as a fallback font typeface here. If, for some reason, the Zen Dots doesn't load properly in your project, then React will use the default cursive typeface that's available on your computer's operating system.

Your WelcomeBack component should now look like this:
WelcomeBack component

*** 21.10 React testing
Program overview

 React testing
Lesson 10
React testing
1.5 hoursEstimated completion time
Learning Objective

In React, unit tests are typically written to check that a given component behaves in a particular way. By the end of this lesson, you will be able to write basic automated tests for React components.
Overview

As your React codebase grows in size and complexity, having automated tests is important to ensure that nothing is broken every time a developer adds new code to the codebase. Otherwise, manually testing every aspect of the app is time consuming and error prone.
Starter code

This lesson requires you to have the following repository running on your local machine.

    GitHub: Starter React testing

Follow the instructions in the README to get it to run.
React Testing Library and Jest

You will use two testing tools, namely React Testing Library and Jest, to create automated tests for your React components.

React Testing Library provides a set of helper methods that allow you to build tests that use your React components the way that a user would. Tests written with the utilities from React Testing Library query the DOM in the same way that the user would; for example, they find links and buttons by their text.

Jest is a testing framework that includes a test runner as well as an assertion library that exposes helper methods that can be used to make assertions about the component being tested.
Setup

The starter-react-testing repo contains several components created in the previous lesson. You will now write automated tests for each of these components.

This is what you will see if you start the project:
localhost:3000 page.

The starter-react-testing repo was bootstrapped with Create React App. Conveniently, projects created with Create React App already come preinstalled and preconfigured with React Testing Library and Jest. That means that you won't have to manually install these testing packages.

Jest will look for test files stored inside of folders titled __tests__. In the starter-react-testing repo, all the test files are stored in the src/__tests__ folder. Because there are four components in this project and one test file per component (which is a standard practice), there are four test files in total. For clarity, each test file's name corresponds to the name of the component that is being tested. For example, the Footer.test.js file contains tests for the Footer component.

The src/setupTests.js is a special Create React App file that allows you to perform a global setup before running your tests. It will be automatically executed before running your tests. Inside this file, the single import statement (import "@testing-library/jest-dom";) loads the jest-dom library into every test file. The jest-dom library adds custom matchers for performing assertions on DOM nodes (such as toHaveTextContent() or toBeInTheDocument()), which you will learn about later on in this lesson.

Note: Although there are more scaleable ways of organizing your React code, especially for bigger projects, this file organization system works well for a relatively small project like this one.
The npm test command

In Create React App, the npm test command by default runs the tests in watch mode, meaning that the tests will automatically rerun every time that a change is made to a test file. It also provides options to run all your tests or just a subset of them. Under the hood, npm test runs the tests using a special package called react-scripts. The react-scripts package contains special configurations that help optimize your Create React App project.
Do this
Run the npm test command

In a new terminal, run the npm test command. Initially, you will see a failure message that says that there are four failing test suites and zero tests in total:

Test Suites: 4 failed, 4 total

Tests:       0 total

Press a to run all tests while in watch mode.

Keep in mind that you'll have to keep the terminal open to run the tests in watch mode. If you need to run any other CLI commands, start a new terminal.
Smoke tests

Different projects may choose different testing techniques based on how often components are updated and how much logic they contain. Although there are many ways to test a component, the simplest way is to use a smoke test that verifies that a component can render without throwing an error. Smoke tests provide tremendous value with minimal code, so they are a great starting point.

To render a component in a test environment, you will need to use the render() method from the React Testing Library, like this:

render(<SomeComponent />);

The render() method accepts a component as an argument, and it simply renders the component into a container which is then appended to document.body.
Do this
Create a smoke test for App

In src/__tests__/App.test.js, add the following code:

import { render } from "@testing-library/react";

import App from "../App";


describe("App", () => {

  test("renders without crashing", () => {

    render(<App />);

  });

});

The render() method and the App component are imported into the file. The describe block groups together all the tests related to the App component. Within the describe block, there is a single test that mounts the App component and verifies that it didn't throw during rendering. At this point, you will see one passing test in the terminal, as follows:

 PASS  src/__tests__/App.test.js


Test Suites: 3 failed, 1 passed, 4 total

Tests:       1 passed, 1 total

Snapshots:   0 total

Time:        3.458 s

To trigger a test failure, try removing the JSX fragment <>...</> from src/App.js. The smoke test will now fail with an error message like the following:

SyntaxError: /Users/houchia/chegg/starter-react-testing/src/App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?

Before moving forward, make sure to fix the syntax error so that your test is passing again. Now you know how to create a smoke test for a React component.
Render tests

Even if a component can render without throwing an error, it is also important to ensure that it is displaying the correct content to the user. For example, the App component is expected to render three Welcome back messages, each containing a different customer name. You can also write tests to verify that the component is rendering the proper content on the screen.

The screen object, which is imported from the React Testing Library, gives you access to a variety of helper methods that allow you to query the DOM where your component has been rendered. An example of a query method is getByText(), which returns the matching element for a query and throws an error if no elements match or if more than one match is found.

For example, you can use getByText() to write a test that checks for the presence of a specific text after a component has rendered:

render(<SomeComponent />);

const text = screen.getByText("Some important text.");

You can then perform assertions on text to determine, for example, if it is present in the DOM, using the toBeInTheDocument() assertion method from the jest-dom library.
Do this
Create a test for Header

In src/__tests__/Header.test.js, add a test to verify that the Header component displays the correct heading:

import { render, screen } from "@testing-library/react";

import Header from "../Header";


describe("Header", () => {

  test("renders the heading", () => {

    render(<Header />);

    const heading = screen.getByText("Header to the page.");

    expect(heading).toBeInTheDocument();

  });

});

Here's the breakdown of the syntax within that test:

    render(<Header />); renders the Header component into a container which is attached to the test DOM.

    const heading = screen.getByText("Header to the page."); queries the DOM for the Header to the page. text, which is the desired heading for the component.

    expect(heading).toBeInTheDocument(); asserts that the desired heading is present in the DOM.

Now, you should see two passing tests in the terminal. Go ahead and change the text in the Header component to trigger a test failure for the component, but make sure to revert the error before moving on.
Using regex in the query

If you're only interested in a partial substring match while querying the DOM, you can also pass a regex, instead of a string, as an argument to getByText(). That will look like this:

render(<SomeComponent />);

const text = screen.getByText(/some important text/i);

Specifying i at the end of the regex allows casing to be ignored when querying the DOM. So, for example, "SOME important TeXt" would be considered a match for this regex.
Do this
Create a test for Footer

Suppose that you would like to make sure that the word footer is part of the Footer component text. In src/__tests__/Footer.test.js, add the following code:

import { render, screen } from "@testing-library/react";

import Footer from "../Footer";


describe("Footer", () => {

  test("renders the footer text", () => {

    render(<Footer />);

    const footerText = screen.getByText(/footer/i);

    expect(footerText).toBeInTheDocument();

  });

});

This time, instead of passing a string to getByText(), you are passing a regex /footer/i as a matching query.

Now, you should see three passing tests in your terminal. Go ahead and remove the footer text from the Footer component to trigger a test failure for the component, but make sure to revert the error before moving on.
Do this
Create tests for WelcomeBack

The WelcomeBack component is interesting because it contains props. You can write tests to ensure that this component is rendering the props properly.

In src/__tests__/WelcomeBack.test.js, add the following code:

import { render, screen } from "@testing-library/react";

import WelcomeBack from "../WelcomeBack";


describe("WelcomeBack", () => {

  test("renders the default value without a name prop", () => {

    render(<WelcomeBack />);

    const text = screen.getByText("Welcome back, valued customer!");

    expect(text).toBeInTheDocument();

  });


  test("renders the customer name passed as a prop", () => {

    render(<WelcomeBack name="John" />);

    const text = screen.getByText("Welcome back, John!");

    expect(text).toBeInTheDocument();

  });

});

Here, you're testing two of the component's desired behaviors. The first test verifies that the component renders a message containing a default customer name if no name prop is specified. And the second test verifies that the component renders a message containing the name prop.

Now, you will see five passing tests in your terminal. Go ahead and change the texts and prop names in the WelcomeBack component to trigger test failures for the component, but make sure to revert any errors before moving on.
Query more than a single element

Up until now, you have been using the getByText() method, which returns a single element if there's a match. However, it is common for a test to query a list of matching elements. If this is the case, you can use the getAllByText() method, which returns an array of all matching elements for a query, and throws an error if no elements match.
Do this
Create a test for App

Suppose that you need to ensure that the App component renders three welcome messages. In src/__tests__/App.test.js, you can add another test within the describe block, like this:

test("renders three Welcome back messages", () => {

  render(<App />);

  const messages = screen.getAllByText(/welcome back/i);

  expect(messages).toHaveLength(3);

});

const messages = screen.getAllByText(/welcome back/i); stores the array of matched elements in messages. expect(messages).toHaveLength(3); asserts that the messages array should contain three matched elements, which is what you'd expect given that App wraps three WelcomeBack components.

At this point, you should see all the tests passing.

Now you understand how to create basic tests for your React components. You can easily run these tests to ensure that your components still render properly whenever you make a code change, without having to manually check each component in the browser. So by using these tests, you'll save both time and effort.

As your React components become more complex, you can also write tests to cover other common use cases. For example, you can simulate user interactions with the component (such as clicking a button in a React component). You can also mock asynchronous operations (such as making an API call) that occur within a component.
Complete example

A completed example from this lesson can be found in this GitHub repository:

    Starter React testing—complete-example branch

** module 22 react state management
*** 22.1 Overview: React state management
Overview: React state management
9 minutesEstimated completion time
Overview

When you were learning about DOM manipulation, one of the most powerful tools that was covered was how to update your page's view through event listeners. In React, changing the view is handled primarily by changing something called state. In this module, you'll learn how to recreate the event listeners that you created earlier, and you'll see the real power behind React.

React's component structure makes it so that managing the state of your application is much more organized and predictable. By the end of this module, you'll be able to update the page's view based on button clicks and form submissions. This will allow you to create a fully featured React application.
Do this

The purpose of the Do this sections in this module is to give you important hands-on experience. In these sections, you'll perform various tasks, like setting up a development environment or executing a command. Ultimately, these practice sections will help you successfully complete graded assessments, such as projects, mock interviews, and capstones.
Learning how to learn

While training to become a developer, one of the most important skills that you can learn is the ability to acquire new skills through self-research (that is, a lot of Googling!) and reading developer documentation. Although employers may not expect each developer they hire to have mastered every technology or process used within the company, they are more likely to expect their hires to be flexible and be able to learn and adapt to them.

The purpose of the Learning how to learn lessons in this module is to give you the opportunity to acquire new knowledge and skills through independent research and learning.

In these sections, you will learn new concepts by perusing the official documentation for a particular technology as well as consulting professional developer forums such as Stack Overflow. You will be provided with several key research questions and resources as a starting point, but feel free to consult any videos, tutorials, and other alternative resources that could help you understand the topic better.
*** 22.2 Interactive components
Interactive components
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to handle events by writing a function that's called when the user clicks an element. You'll also be able to store and update the component's state using the useState() hook.
Overview

In this lesson, you'll learn how to build interactive components that allow the user of the website to modify the overall state of the page. For example, when the user clicks a button, you may want some part of your page to either show up or hide. This is similar to the way that event handlers work—but hopefully, you'll find this a bit easier.
Key Terms

Hook
    A special React function that gives you access to some React process
One-way data flow
    Also called one-way binding, the idea that changes in the props or state will cascade downward to cause changes further on

Starter code

In this lesson, you will want to have a project running that was created using the Create React App command-line tool. You may be asked to create a component and include it in your App.js file.
What is state?

The term state and how it relates to React has its origins with the state machine. The concept of the state machine can feel quite abstract for new programmers. However, there is an easier way to think about state.

Generally, when a user presses a button or enters data in a form, you will want to store some information. React components use state to store information that is updated by the component. State refers to data that affects how an application behaves and is rendered. For example, if you're logged into an application, the state of that application is different than when you are not logged in. Based on the state of the application, certain functionalities may be available to you.

Every React component can have its own state.
Handling events

The video below provides a brief introduction to this topic. Start by watching the video, and then read through the rest of the lesson. This will give you a thorough understanding of these concepts.

You will start with the simplest interactive component: a button. You'll get familiar with the JSX code for a button and see how to cause an action when the button is clicked.

First, take a look at the following anonymous function for the onClick event. This function just logs to the console when the button is clicked.

<button onClick={() => console.log("Subscribing!")}>Subscribe</button>

If you have more that you want to do, you can write a named function instead of an anonymous function. Here's an example:

const handleClick = () => {

  console.log("Subscribing!");

  alert("You subscribed!");

};


<button onClick={handleClick}>Subscribe</button>;

Do this
Add an event handler

In the App.js of the React application that you created, add a button to the page. Give it the following function as the value to its onClick attribute.

const handleClick = (e) => console.log(e.target);

Save your file and then go to your rendered page. Click the button and take a look at the console. You will see that the button's DOM element is logged out.

As you can see, you've added an event listener to the button.
Props versus state

When the user presses a button, you will usually want to store some information in the application state. For example, when you submit a post on a social media site, that post might be saved in the application state itself.

You might think that you can store this information in the props. However, recall that components are pure functions—they should never edit the props. If the props need to change, they are edited by the parent component.

State, on the other hand, is where the component stores information that it can modify. Parent components do not have access to the state of their child components.
The useState() hook

The video below provides an overview of the useState() hook.

Take a look at the following App component:

import React from "react";


function App() {

  const handleSubscribe = (e) => console.log("User has been subscribed...");


  return (

    <section>

      <p>Please click to subscribe to my updates!</p>

      <button onClick={handleSubscribe}>Subscribe</button>

    </section>

  );

}


export default App;

When the user clicks the button, a message will be logged, but no feedback will be given to the user.

In order to create and edit the state—which can allow you to change the interface—you need to use the useState() hook. A hook is a special React function that gives you access to (or hooks into) some React process. So useState() hooks into the component's state.

To use the useState() hook, you will first need to add it to your import statement, like this:

import React, { useState } from "react";

Now, inside of your component, you can call useState(), as follows:

const [subscribed, setSubscribed] = useState(false);

The code above creates a new state variable called subscribed. The useState() function takes the initial value of the state variable (in this case, false). It returns the variable, subscribed. It also returns a function, setSubscribed(), that is used to update the state variable.

The convention for creating a state variable with useState() is to name the function set[VariableName]. So if the variable is userId, the function will be setUserId().
Do this
Update your code to use the state

Update your current App code to this:

import React, { useState } from "react";


function App() {

  const [subscribed, setSubscribed] = useState(false);


  return (

    <section>

      <p>Please click to subscribe to my updates!</p>

      <button onClick={() => setSubscribed(true)}>Subscribe</button>

    </section>

  );

}


export default App;

Right now, when you click the Subscribe button, the state will change, but nothing on the page will change.
Make use of the state

Update the text of your button with the information below:

<button onClick={() => setSubscribed(true)}>

  {subscribed ? "Unsubscribe" : "Subscribe"}

</button>

Now, when you click the button, you will see the text in the button change.

Take a moment to try to make it so that whenever the button is clicked, the text changes back and forth between Unsubscribe and Subscribe. If you get stuck, consult the solution below.

<button onClick={() => setSubscribed(!subscribed)}>

  {subscribed ? "Unsubscribe" : "Subscribe"}

</button>

Re-rendering

In the example above, you modified the state by using the setSubscribed() function. As you can see, when the state changes, the text on the button changes.

Whenever the state is updated, the component re-renders using the new information. This means the entire component gets called again—including all of the code inside of the component function.

This is an important concept in React. When the props or state change for a component, that component and its children are re-rendered with the new information. This allows changes to flow downward.

Put another way, data flows from parent components down to the child components, making changes as needed. This is generally known as one-way data flow. One-way data flow, or one-way binding, refers to the idea that changes in the props or state will cascade downward to effect changes further on. In other words, the parent component's data is the single source of truth for how that component and its children should render.
Do this
Watch the re-render

Try adding the following log() statement right above the return statement in your component.

console.log("Subscribed status:", subscribed);

Then, on your application's page, open up the web console and click the button. You will see the log() statement show up each time that you click.
Log statements on web console

Note: You'll notice that the logs actually appear twice. This is because of the React.Strict component wrapper. The details behind this wrapper are beyond the scope of this lesson, but it's safe to ignore this double-logging.
Never edit the state directly!

To update the state and cause the component to re-render, you will always need to use the function provided by useState(). Setting the state directly will not do this.

For example, the following code won't perform correctly:

<button onClick={() => (subscribed = !subscribed))}>

  {subscribed ? "Unsubscribe" : "Subscribe"}

</button>

Multiple states

You can call the useState() function multiple times. This is common for complex components.

For example, take a look at the following component, which includes two different calls of useState(). Each state value can be changed independently of the other.

function App() {

  const [subscribed, setSubscribed] = useState(false);

  const [alerts, setAlerts] = useState(false);


  return (

    <section>

      <p>Please click to subscribe to my updates!</p>

      <button onClick={() => setSubscribed(!subscribed)}>

        {subscribed ? "Unsubscribe" : "Subscribe"}

      </button>

      <button onClick={() => setAlerts(!alerts)}>

        {alerts ? "Stop Email Alerts" : "Get Email Alerts"}

      </button>

    </section>

  );

}
*** 22.3 Testing interactive components
Testing interactive components
2 hoursEstimated completion time
Learning Objective

By the end of this lesson, you'll be able to interpret tests related to testing interactive components.
Overview

In the previous module, you learned how to write basic automated tests for your components using the React Testing Library and Jest. You wrote smoke tests to verify that your components can render without throwing errors. You also learned to write tests to ensure that components are rendering the correct content when given different kinds of props. As your React components become more complex, you can also write tests to cover other common use cases. For example, your tests can simulate user interactions with the component (such as clicking a button in a React component) and mock asynchronous operations (such as making an API call) that occur within a component.
Learning how to learn

Keep in mind that the purpose of the Learning how to learn lessons in this module is to give you the opportunity to acquire new knowledge and skills through independent research and learning. This is one of the most important skills that you need to develop and practice as a software developer over your career: learning new things and relearning things that you already "know." No program can teach you everything. This program aims to teach you the fundamentals, as well as the ability to teach yourself so you continue to grow over time.

In these sections, you will learn new concepts by perusing the official documentation for a particular technology. You'll also consult professional developer forums such as Stack Overflow. You will be provided with several key research questions and resources as a starting point, but feel free to also study alternative resources (such as videos and tutorials) that could help you understand the topic better.

When a particular concept or syntax keeps coming up in your research of a particular technology, it's often a good sign that that concept or syntax is key to understanding the bigger picture—so you may want to dive deeper into that concept or syntax.

For example, if a third-party library method keeps coming up in your research, you could focus on learning more about that method. You could learn about its use cases—when you would or wouldn't apply that particular method in code. You could also study what you need to know to use the method correctly, such as the proper arguments to pass the method.

The practice questions at the end of this lesson will assess your understanding of the concepts required for this lesson.
Tip

To further reinforce what you've learned on your own, it's a good idea to explain and discuss your new knowledge with a classmate.
Thinking like a developer

Developer documentation is one of the most important tools for software developers. Developer documentation helps developers interface with a given software service or library. As a software developer, you'll often refer to documentation to understand how to use a language or library.

Not all documentation is created equally. Some documentation is well written, but some isn't. Most documentation is written by developers, and although developers may be good at writing instructions for computers to execute, they aren't necessarily quite as good at writing instructions that people can easily understand.

The first step to navigating through developer documentation is to understand how it is organized. For example, on the React Testing Library website, you can see that that part of the documentation includes several sections:
The React Testing Library website.

The interactive outline on the left pane helps you navigate through the documentation, and it also provides an overview of the key sections available in the documentation for React Testing Library. The React Testing Library documentation includes the following sections:

    Introduction, which provides an overview of the React Testing Library

    Example, which provides a step-by-step example of how to set up a test suite with React Testing Library

    Setup, which describes in detail how to set up a test with React Testing Library

    API, which provides a list of methods that developers can use to interface with the React Testing Library

    Migrate from Enzyme, which includes instructions on how to migrate to React Testing Library from a legacy technology

    FAQ, which is the frequently asked questions page

    Cheatsheet, which is a short guide to using React Testing Library

Good documentation typically contains the basic elements described above.
Key questions

One of the most important responsibilities for a React developer is writing automated tests to ensure that any React components continue to work as expected as the codebase grows in size and complexity. To do this effectively, automated tests will often have to simulate user interactions with the components as well as mock or fake asynchronous operations such as API calls that occur within the components.

Although there are many testing libraries and frameworks for React, you will focus your independent research on React Testing Library and Jest for this lesson. Here are some broad research questions to consider:

    What are integration tests? How do they differ from unit tests?

    Why use React Testing Library? What are its guiding principles?

    What are the steps involved in setting up a test with the React Testing Library to test a user interaction (such as a click)?

    What are mocks, and why would mocks be used in testing?

    What are some ways you could mock, for example, an API request in your test code (are there libraries that make this easier)?

Key concepts and syntax

While you're researching the broad questions outlined above in the context of React Testing Library and Jest, you may notice that the following concepts and syntax come up frequently in your research. So make sure to pay particular attention to them!

    fireEvent.change()

    fireEvent.click()

    fireEvent.submit()

    jest.clearAllMocks()

    jest.fn()

    jest.mock()

    jest.spyOn()

The official React testing library documentation has a section about the fireEvent() methods.

The Jest methods are documented here, so you can look up the specific methods that you're interested in learning more about.
Resources

The React testing library documentation is a good starting point, but feel free to consult other resources.
*** 22.4 Asynchronous state
Asynchronous state
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to recognize when updating the state may cause race conditions. You'll also be able to refactor the code to avoid issues with race conditions.
Overview

Updating state is a process that happens asynchronously. And just like with other asynchronous operations in JavaScript, some odd bugs can occur, depending on what you're attempting to do. In this lesson, you'll see that you can get some unexpected behavior if you try to update the same state twice in a row. You'll also learn how to fix those problems.
Key Terms

Race condition
    Also called a race hazard, a condition where a program depends on the relative timing of one or more processes to function correctly

Starter code

Use a new or existing project created with the Create React App command-line tool. Then, include the following App component:

function App() {

  const [subscribed, setSubscribed] = useState(false);

  const [subscribedCount, setSubscribedCount] = useState(0);

  const [alerts, setAlerts] = useState(false);


  return (

    <section>

      <p>Please click to subscribe to my updates!</p>

      <p>Subscriber Count: {subscribedCount}</p>

      <button

        onClick={() => {

          setSubscribed(!subscribed);

          setSubscribedCount(subscribedCount + 1);

          if (!alerts) setAlerts(true);

        }}

      >

        {subscribed ? "Unsubscribe" : "Subscribe"}

      </button>

      <button onClick={() => setAlerts(!alerts)}>

        {alerts ? "Stop Email Alerts" : "Get Email Alerts"}

      </button>

    </section>

  );

}

The code above will render as follows:
React App starter code, rendered

When you click the Unsubscribe button (which is also the Subscribe button), the following happens:

    The subscribed state is toggled.

    The subscribedCount is increased by 1.

    If the alerts are false, they are set to true.

Multiple updates

As you can see with the starter code, it is possible to make multiple changes to different states. But a problem arises when you try to make multiple changes to the same state at the same time.

For example, in the code below, setSubscribedCount() is called twice. Can you guess what this will do?

<button

  onClick={() => {

    setSubscribed(!subscribed);

    setSubscribedCount(subscribedCount + 1);

    setSubscribedCount(subscribedCount + 1);

    if (!alerts) setAlerts(true);

  }}

>

  {subscribed ? "Unsubscribe" : "Subscribe"}

</button>

If you try this locally, you'll notice that despite setSubscribedCount() being called twice, the subscribedCount only increases by 1.

This is because the updates to the state are done asynchronously. So when setSubscribedCount() is called twice in a row, both calls use the same initial value for subscribedCount.

For example, imagine that subscribedCount is 0. When you press the button, the first call to setSubscribedCount() sees the subscribedCount as 0 and updates it to 1. Then, the second call to setSubscribedCount() also sees the subscribedCount as 0 and also updates it to 1.
Passing a function for state updates

There are a few ways to solve this problem. One is to simply rewrite the setSubscribedCount() function to increment by 2 instead of 1.

However, there may be situations where this isn't ideal. So instead, you could pass setSubscribedCount() a function that takes the previous value of the state, as follows:

setSubscribedCount((currentCount) => currentCount + 1);

Using a function means that you will avoid potential race conditions. Instead of taking the value of subscribedCount, which is subject to change, the function will ensure that whatever the most recent value is, it will add 1 to it.

Review the updated code below:

function App() {

  const [subscribed, setSubscribed] = useState(false);

  const [subscribedCount, setSubscribedCount] = useState(0);

  const [alerts, setAlerts] = useState(false);


  return (

    <section>

      <p>Please click to subscribe to my updates!</p>

      <p>Subscriber Count: {subscribedCount}</p>

      <button

        onClick={() => {

          setSubscribed(!subscribed);

          setSubscribedCount((currentCount) => currentCount + 1);

          setSubscribedCount((currentCount) => currentCount + 1);

          if (!alerts) setAlerts(true);

        }}

      >

        {subscribed ? "Unsubscribe" : "Subscribe"}

      </button>

      <button onClick={() => setAlerts(!alerts)}>

        {alerts ? "Stop Email Alerts" : "Get Email Alerts"}

      </button>

    </section>

  );

}
*** 22.5 State over multiple components

State over multiple components
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to manage state over multiple components.
Overview

Imagine that you want to build a page that has a header at the top with buttons that change the appearance of the whole page. For example, imagine that the header has buttons to log in and log out, change the color theme, and change the font size. These buttons will affect the appearance of several components on the page. In this lesson, you'll learn how to build such a page.
Key Terms

Lifting up state
    The process of moving state higher up in a component tree, enabling state to be passed from a parent component to multiple children

The video below provides a brief introduction to this topic. Start by watching the video, then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of these concepts.
Starter code

Use a new or existing project created with the Create React App command-line tool. Then, include the following App component:

function App() {

  return (

    <div>

      <Header />

      <Content />

    </div>

  );

}

Then, create two new files: Header.js and Content.js. Include the following components in the corresponding files.

// Header.js

function Header() {

  // TODO: define loggedIn

  return (

    <button onClick={/* TODO */}>{loggedIn ? "Log Out" : "Log In"}</button>

  );

}


// Content.js

function Content() {

  // TODO: define loggedIn

  return loggedIn && <p>CONTENT</p>;

}

In this example, App is the parent component and Header and Content are child components. Header and Content are considered sibling components to each other. These relationships are visualized in the following diagram:
Diagram showing Header and Content as children of App, as in a family tree.
Lifting up state

The program that you are building has three different components: App, Header, and Content.

You might imagine that the Header component contains the loggedIn state. But this wouldn't work well, because the Content component needs access to the loggedIn state to know what to display.

Siblings cannot share state. This is because there is no natural way for a sibling to pass props "sideways" to another sibling. Data only flows in one direction in React. Likewise, a child cannot share state with its parent, because there is no way for a child to pass props to its parent. Yet, parents can share state with their children through props.

So, for both the Header and the Content components to have access to the loggedIn state, you need to hold that state in the App component and pass it to the children through props. Also, the Header component needs to be able to update the loggedIn state when the user presses the button. The toggleLoggedIn() function below can be passed down as a prop to the Header component.

You could write this as follows:

function App() {

  const [loggedIn, setLoggedIn] = useState(false);

  const toggleLoggedIn = () => setLoggedIn(!loggedIn);

  return (

    <div>

      <Header loggedIn={loggedIn} handleLoggedInClick={toggleLoggedIn} />

      <Content loggedIn={loggedIn} />

    </div>

  );

}

Then you can complete the Content and Header components to use the props that are passed to them from the App component.

// Header.js

function Header({ loggedIn, handleLoggedInClick }) {

  return (

    <button onClick={handleLoggedInClick}>

      {loggedIn ? "Log Out" : "Log In"}

    </button>

  );

}


// Content.js

function Content({ loggedIn }) {

  return loggedIn && <p>CONTENT</p>;

}

This concept is generally referred to as lifting up state. State moves from a child component "higher" up the component tree. With state higher up in the tree, the data can flow downward more easily.
Do this
Update your application

Update your code as described above. Then try out the changes and see how state can be shared as a prop over multiple components.
State as props

When you pass down state to children components, your state becomes part of the props for the child component. In this way, children components don't necessarily distinguish between state and props.

For example, you could update your Content component to include a text prop that could be passed in, as shown below:

// In App.js

<Content loggedIn={loggedIn} text="My content." />;


// Content.js

function Content({ loggedIn, text }) {

  return loggedIn && <p>{text}</p>;

}

This way, in App.js, loggedIn is a part of the potentially changing state for that component. But in Content.js, loggedIn looks like just another property.
*** 22.6 Arrays and objects as state

Arrays and objects as state
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use an array or object as a state value and update the state correctly.
Overview

You can use any kind of data type as the argument in your useState() function. However, mutable data types like objects and arrays may not work exactly the way that you expect. The function returned from useState() expects a new value to be placed inside of the function. As you'll see in this lesson, that means that you'll need to create a new array or object each time.
Starter code

Use a new or existing project created with the Create React App command-line tool. Then, include the following App component:

function App() {

  return <CoinTossCounter />;

}

Next, create a CoinTossCounter component in a file called CoinTossCounter.js. This file should have the following contents:

function CoinTossCounter() {

  const handleClick = (value) => {

    // TBD

  };

  return (

    <section>

      <div>

        <button onClick={() => handleClick("H")}>Heads</button>

        <button onClick={() => handleClick("T")}>Tails</button>

      </div>

    </section>

  );

}

Include imports and exports as needed.
Array as state

To keep track of the results for your coin-toss application, it makes sense to use an array. That way, you can end up with something like the following as your state's value.

["H", "T", "H", "H"];

To do this, you can create a state object with a default value of an empty array, like this:

const [results, setResults] = useState([]);

Now, you can fill in the handleClick() function. The results state is an array, which is a mutable object in JavaScript. However, keep in mind that you never want to edit the state directly. Because the state is updated asynchronously, directly editing it may not have the expected results.

Instead, create a new results array that has all the old contents as well as the new value at the end. Then, pass this array to the setResults() function, as follows:

const handleClick = (value) => {

  setResults([...results, value]);

};

The above code uses the spread operator ... to include all of the contents of the existing results variable and add the new value to the very end.
Do this
Implement changes

Update your code to include the changes mentioned above in the CoinTossCounter component. Add a console.log() statement so that you can watch the array stored inside of results change.
Complete the CoinTossCounter component

Update your CoinTossCounter so that it shows each toss as part of a list after the buttons. An example solution is included below.

function CoinTossCounter() {

  const [results, setResults] = useState([]);

  const handleClick = (value) => setResults([...results, value]);


  const lis = results.map((result, index) => (

    <li key={`toss-${index}`}>{result === "H" ? "Heads" : "Tails"}</li>

  ));

  return (

    <section>

      <div>

        <button onClick={() => handleClick("H")}>Heads</button>

        <button onClick={() => handleClick("T")}>Tails</button>

      </div>

      <ul>{lis}</ul>

    </section>

  );

}

Deleting elements

You may want to give the user the ability to delete an item from an array. The most common way to delete an item from an array in React is to use the filter() function of the array.

If you know the index of the element, you can delete by index, like this:

const deleteToss = (indexToDelete) => {

  setResults((currentResults) =>

    currentResults.filter((ignored, index) => index !== indexToDelete)

  );

};

You can also delete by the value or any property of the element in the object. For example, if you have a list of users loaded from a database, it is common to delete by ID, like this:

const deleteUser = (idToDelete) => {

  setUsers((currentUsers) =>

    currentUsers.filter((user) => user.id !== idToDelete)

  );

};

Do this
Add a Delete Last button

Add a Delete Last button to your existing project. Start by adding a new button with the correct label, as shown below:

<button onClick={handleDeleteLast}>Delete Last</button>

This button should only delete the last coin flip in the list. When the button is clicked, a function called handleDeleteLast() should be called. Now, write the handleDeleteLast() function so that it correctly modifies the state. A solution is included below in case you need it.

const handleDeleteLast = () => {

  const filteredList = results.filter(

    (result, index) => index !== results.length - 1

  );

  setResults(filteredList);

};

Object as state

Storing state inside of objects works very similarly. Each time that you make a change to the state, you will need to return a new object with its old contents. Once again, the spread operator is crucial for writing readable code.

Imagine that you also want to keep track of the number of heads and tails. Although you can do this by searching through the array, it can be more efficient to store these numbers as an object.

After getting two heads and one tails, the object should look like this:

{

  H: 2,

  T: 1

}

First, you'll need to create a new state object, like this:

const [counts, setCounts] = useState({ H: 0, T: 0 });

Then, you can update the counts state in the handleClick() function. Take a look:

const handleClick = (value) => {

  setResults([...results, value]);

  setCounts({

    ...counts,

    [value]: counts[value] + 1,

  });

};

The object passed in as an argument in the above setCounts() function works as follows:

    Create a new object.

    Include all the key-value pairs inside of counts, which should include only the H key and the T key.

    Create a new key for the given value. This will overwrite either H or T.

    Set that new key's value to the current value plus 1.

Do this
Update your code

Update your code according to the instructions above. To see the changes to counts, you can add a log() statement within your CoinTossCounter component.
Display the results

Include the following in your component, below the buttons.

<ul>

  <li>Heads: {counts["H"]}</li>

  <li>Tails: {counts["T"]}</li>

</ul>

When you click the Heads and Tails buttons, you will now see the visible counts increase.
Fix the Delete Last button

Unfortunately, the Delete Last button no longer works. Because the handleDeleteLast() only calls the setResults() function, the counts object isn't being changed.

Update the code so that when the Delete Last button is clicked, the counts object is modified correctly as well. A solution has been included below; consult the solution if you get stuck.

const handleDeleteLast = () => {

  const last = results[results.length - 1];

  const list = results.slice(0, -1);


  setResults(list);

  if (last) {

    setCounts({

      ...counts,

      [last]: counts[last] - 1,

    });

  }

};

Note: There are a few changes in the code above. The slice() method is used to remove the last element of the array and to create a new array.

*** 22.7 Forms with input fields

Forms with input fields
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to track the state of a form with multiple input fields.
Overview

Forms and inputs provide their own unique challenges in React. In part, this is because several different events can be fired from forms and inputs. In this lesson, you'll learn how to track a form's state in React by building a component where someone can enter their name and email into input fields.
Key Terms

Controlled component
    A form element whose value is managed in React state

Start by watching the video below, which provides a brief introduction to the topics covered in this lesson. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.
Starter code

Use a new or existing project created with the Create React App command-line tool. Then, include the following App component:

function App() {

  return <SubscriberForm />;

}

Create a SubscriberForm component in a file called SubscriberForm.js. This component should have the following contents:

function SubscriberForm() {

  return (

    <form>

      <label htmlFor="name">

        Enter Your Name:

        <input type="text" id="name" name="name" />

      </label>

      <label htmlFor="email">

        Your Email:

        <input id="email" type="email" name="email" />

      </label>

    </form>

  );

}


export default SubscriberForm;

Include imports and exports as needed.
Controlled components

There are several reasons that you may want to access the value inside of an input field. But how can you get access to this value?

Take a look at the following code, which tracks the changes of a single input field.

function SubscriberForm() {

  const [name, setName] = useState("");

  const handleNameChange = (event) => setName(event.target.value);


  console.log("Current value of name:", name);

  return (

    <form>

      <label htmlFor="name">

        Enter Your Name:

        <input

          id="name"

          type="text"

          name="name"

          onChange={handleNameChange}

          value={name}

        />

      </label>

      <label htmlFor="email">

        Your Email:

        <input id="email" type="email" name="email" />

      </label>

    </form>

  );

}

The following is true of the code above:

    The handleNameChange() event is called every time that any change is present in the name input field.

    event.target.value references the current contents of the input field.

    The value attribute of the input field is tied to the name state variable.

    The email field isn't being tracked by state.

When this code is run and the name Ada is typed into the form, the logged output will look something like this:

"Current value of name:" ""

"Current value of name:" "A"

"Current value of name:" "Ad"

"Current value of name:" "Ada"

As you can see, the state value is being updated after every keystroke.

The name input in the above example is called a controlled component. That is, it's a form element whose value is managed in React state.
Do this
Update the SubscriberForm component

Update your SubscriberForm component to include the code above. Run it and test out the form, noting how the state changes.
Track changes for the email field

Update your SubscriberForm component so that changes made to the email field are tracked as well. This should look very similar to how the name field is being handled. A potential solution is included below; feel free to consult it as needed.

function SubscriberForm() {

  const [name, setName] = useState("");

  const [email, setEmail] = useState("");

  const handleNameChange = (event) => setName(event.target.value);

  const handleEmailChange = (event) => setEmail(event.target.value);


  console.log("Current value of name:", name);

  console.log("Current value of email:", email);

  return (

    <form>

      <label htmlFor="name">

        Enter Your Name:

        <input

          id="name"

          type="text"

          name="name"

          onChange={handleNameChange}

          value={name}

        />

      </label>

      <label htmlFor="email">

        Your Email:

        <input

          id="email"

          type="email"

          name="email"

          onChange={handleEmailChange}

          value={email}

        />

      </label>

    </form>

  );

}

Submitting

When the form is submitted, it's also possible to capture the submission event. This is useful when you want to use all of the form's information for a particular event.

To capture the submission event, use the onSubmit event in the form, as demonstrated below, and give it a function with a name like handleSubmit().

<form onSubmit={handleSubmit}>

Inside the handleSubmit() function, you'll need to prevent the default behavior of form submissions, as shown below. Then, you can do whatever you like with the information that you've collected.

const handleSubmit = (event) => {

  event.preventDefault();

  console.log("Submitted:", name, email);

};

Finally, you'll need to add a Submit button inside the form, like so:

<button type="submit">Submit</button>

Do this
Update your form

Update your existing form to include the onSubmit attribute, the handleSubmit() function, and the Submit button. Test out your code and look at the logs to confirm that it is working as intended.
Clear the form after submit

Update your handleSubmit() function to clear the form after submit. You can do this by setting the state of name and email to be empty strings. If needed, consult the solution below.

const handleSubmit = (event) => {

  event.preventDefault();

  console.log("Submitted:", name, email);


  setName("");

  setEmail("");

};

Managing a list of subscribers

Imagine that you work at a high-tech magazine and you're building an admin tool that allows the customer support department to add and remove subscribers from the system.

Whenever customer support submits the form, the new subscriber should be displayed on the page. For example, if you submit the form with a name of Jane Doe and an email of jane.doe@gmail.com, you should get the following result:
New subscriber displayed on page.

And if you then submit the form with a name of John Doe and an email of john.doe@gmail.com, the new subscriber should be added to the top of the subscriber list, like so:
Newest subscriber displayed at the top.

The customer support department should be able to add as many subscribers as they like, and they should be able to remove a subscriber from the list by pressing Unsubscribe.

Start by thinking about the new components that you'd need to build for this new feature. Remember the single-responsibility principle, which states that each component should only perform a single responsibility or function. With that in mind, it's reasonable to create new components that are responsible only for displaying the list of subscribers.

Below, you will create two new components: SubscriberList and SubscriberView. Each SubscriberView component is responsible for displaying the name, email, and "Unsubscribe" button for each subscriber, whereas the SubscriberList component simply displays a list of SubscriberView components.

You should also think about any state that needs to be stored in the application. Because the app now has a list of subscriber data that gets updated whenever the form is submitted, you'd have to store the subscribers data in state.

Which component should the subscribers state be stored in? Earlier in the module, you learned about the concept of lifting state up; you learned that sibling components cannot easily share state with each other directly, but that parent components can easily pass their state down to their children components.

So because the SubscriberForm and SubscriberList components both need access to the subscribers state, you can store the state in the parent component, which is the App component in this case. The App component will then pass the state down to the SubscriberForm and SubscriberList components via props.
Do this
Update the App component

Update the App component with the subscribers state, including handlers to create (createSubscriber()) and delete (deleteSubscriber()) subscribers, as follows:

import { useState } from "react";

import SubscriberForm from "./SubscriberForm";

import SubscriberList from "./SubscriberList";


function App() {

  const [subscribers, setSubscribers] = useState([]);


  const createSubscriber = (newSubscriber) =>

    setSubscribers((currentSubscribers) => [

      newSubscriber,

      ...currentSubscribers,

    ]);


  const deleteSubscriber = (indexToDelete) =>

    setSubscribers((currentSubscribers) =>

      currentSubscribers.filter((post, index) => index !== indexToDelete)

    );


  return (

    <>

      <SubscriberForm createSubscriber={createSubscriber} />

      <SubscriberList

        subscribers={subscribers}

        deleteSubscriber={deleteSubscriber}

      />

    </>

  );

}

Here, App is the parent component of the SubscriberForm and SubscriberList components. To allow these components access to the subscribers state and handlers, App passes them down through props.
Create the SubscriberList component

In the src folder, create a new file called SubscriberList.js. Add the following code:

import SubscriberView from "./SubscriberView";


function SubscriberList({ subscribers, deleteSubscriber }) {

  return (

    <>

      <h2>Subscribers</h2>

      <ul>

        {subscribers.map((subscriber, index) => (

          <SubscriberView

            deleteSubscriber={() => deleteSubscriber(index)}

            key={index}

            subscriber={subscriber}

          />

        ))}

      </ul>

    </>

  );

}


export default SubscriberList;

The SubscriberList component simply returns some JSX containing a h2 heading and a list of subscribers. Here, you'll map through the list of subscribers (which are available via props) and render each subscriber using the SubscriberView component, which you will create next.

Note that the SubscriberList component also passes down the deleteSubscriber() handler as a prop to the SubscriberView component, because the SubscriberView component will have a delete button that relies on this handler to work properly.
Create the SubscriberView component

In the src folder, create a new file called SubscriberView.js. Add the following code:

function SubscriberView({ subscriber, deleteSubscriber }) {

  return (

    <li>

      <p>Name: {subscriber.name}</p>

      <p>Email: {subscriber.email}</p>

      <button name="delete" onClick={deleteSubscriber}>

        Unsubscribe

      </button>

    </li>

  );

}


export default SubscriberView;

The SubscriberView component returns some JSX containing the subscriber's name and email, and a button that when clicked will invoke the deleteSubscriber() handler that's available via props.
Update the SubscriberForm component

Because you have now created a handler for creating a new subscriber, you need to call this method once the form is submitted. You will need to update the SubscriberForm component so that it can access the createSubscriber function.

First, change the function declaration, as follows:

function SubscriberForm({ createSubscriber }) {

Then, update the handleSubmit() function:

  const handleSubmit = (event) => {

    event.preventDefault();

    console.log("Submitted:", name, email);

    createSubscriber({name, email});

    setName("");

    setEmail("");

  };

You will see the subscriber list populate once you submit the form.

The frontend of your admin tool feature will now be complete, so try it out in the browser. Note that every time you refresh your browser, the list of subscribers will get reset because the data is only stored temporarily in an array.

*** 22.8 Complex forms

Complex forms
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use checkboxes, radio buttons, and select inputs in React forms.
Overview

With what you've already learned about forms, you can build more complex forms that make use of checkboxes, radio buttons, and other input types. Additionally, you can easily update your forms to incorporate multiple new types of values. In this lesson, you'll see how different input types can be used to build a complex form.
Starter code

Use a new or existing project created with the Create React App command-line tool. Then, include the following App component:

function App() {

  return <SubscriberForm />;

}

Next, create or update the SubscriberForm component in a file called SubscriberForm.js. This component should have the following contents:

function SubscriberForm() {

  const initialFormState = {

    name: "",

    email: "",

  };

  const [formData, setFormData] = useState({ ...initialFormState });

  const handleChange = ({ target }) => {

    setFormData({

      ...formData,

      [target.name]: target.value,

    });

  };


  const handleSubmit = (event) => {

    event.preventDefault();

    console.log("Submitted:", formData);

    setFormData({ ...initialFormState });

  };


  return (

    <form onSubmit={handleSubmit}>

      <label htmlFor="name">

        Enter Your Name:

        <input

          id="name"

          type="text"

          name="name"

          onChange={handleChange}

          value={formData.name}

        />

      </label>

      <br />

      <label htmlFor="email">

        Your Email:

        <input

          id="email"

          type="email"

          name="email"

          onChange={handleChange}

          value={formData.email}

        />

      </label>

      <br />

      <button type="submit">Submit</button>

    </form>

  );

}

Include imports and exports as needed.
Initial form state

In the above example, a variable initialFormState is declared at the top of the form, like so:

const initialFormState = {

  name: "",

  email: "",

};

This object is then used in a few places:

    The initial state stored in formData is created from this object.

    When the form is reset, a new object is created from this object.

Including an initial form state can be quite useful in your forms, for several reasons:

    The information that your form stores is recorded at the top of the component. This makes it easy to know what your form is recording.

    Instead of calling useState() multiple times in your component, you only need to call it once.

    Instead of ending up with multiple state functions (such as setName() and setEmail()), you only have one.

    Resetting the form to its initial state becomes trivial.

However, if you add new inputs to your form, this object will not be updated automatically. If you decide to use an initialFormState variable, you will need to add keys whenever you add a new input field.

In this lesson, you'll use initialFormState and keep it updated throughout.
Do this
Set a default name

In the initialFormState variable, change the empty string to a string with your name in it. On the rendered form, you'll see that your name shows up in the input field.

This ability to set default values can also be useful when creating forms.
Additional input types

Text inputs all work very similarly when it comes to including them in a React form. Other types of inputs are also similar, but there are a few important differences. These differences are detailed below.
The select elements

The select elements work very similarly to inputs, except that they make use of the option element, as shown below:

<label htmlFor="referral">

  How did you hear about us?

  <select

    id="referral"

    name="referral"

    onChange={handleChange}

    value={formData.referral}

  >

    <option value="">-- Select an Option --</option>

    <option value="twitter">Twitter</option>

    <option value="wom">Word of Mouth</option>

    <option value="youtube">YouTube</option>

  </select>

</label>

In the example above, you can see that the onChange and value attributes for the select element are similar to other elements. Note that each option element must have a value associated with it, which will be recorded under the select element's name.
Do this
Update your form

Add the code above to your form. Then update your initialFormState to include a referral key with a value of an empty string, like this:

const initialFormState = {

  name: "",

  email: "",

  referral: "",

};

Then, try selecting one of the items from the drop-down and submitting the form. Take a look at the console and confirm that your form works as intended.
Set a value

Try setting the referral key to a specific value so that it is chosen as the first option. For example, you could set the value inside of initialFormState to twitter.
Radio buttons

Radio buttons are a bit different from select elements, in that there is no grouping for radio buttons in the same way there is for select elements. Instead, radio buttons are grouped by being given the same name. Here's an example:

<fieldset>

  <legend>How old are you?</legend>

  <label htmlFor="low">

    Under 18

    <input

      id="low"

      type="radio"

      name="age"

      onChange={handleChange}

      value="low"

      checked={formData.age === "low"}

    />

  </label>

  <label htmlFor="middle">

    18 - 60

    <input

      id="middle"

      type="radio"

      name="age"

      onChange={handleChange}

      value="middle"

      checked={formData.age === "middle"}

    />

  </label>

</fieldset>

Note: A fieldset element isn't actually required for radio buttons. This is just to help group the elements on your page.

In the example above, the first label and input have an id and value of low. However, the name attribute is set to age. This name attribute is shared with the second input.

The radio button can be set to the appropriate value using the checked attribute. If the value stored inside of the formData matches the name of the input, it will be selected. Otherwise, it won't be selected.
Do this
Update your form

Add the code above to your form. Then update your initialFormState to include an age key with a value of an empty string, like this:

const initialFormState = {

  name: "",

  email: "",

  referral: "",

  age: "",

};

Then, try selecting one of the radio buttons and submitting the form. Take a look at the console and confirm that your form works as intended.
Add a new radio button

Add a new radio button with a name of high for people over the age of 60. Make sure to change the value of checked so that it can be selected by default if needed.
Checkboxes

Checkboxes are strange in that they don't typically operate based on the value. Instead, they operate based on whether or not they are checked.

<label htmlFor="subscription">

  Receive email notifications?

  <input

    id="subscription"

    type="checkbox"

    name="subscription"

    onChange={handleChange}

    checked={formData.subscription}

    value="subscription"

  />

</label>

This looks similar to how radio buttons work. But if you try clicking the actual checkbox, it will not change and an error will be displayed in the console about an uncontrolled input. This is because the value, no matter what the state of the checkbox is, will always be subscription.

This means that you'll need to update your handleChange() function as follows:

const handleChange = ({ target }) => {

  const value = target.type === "checkbox" ? target.checked : target.value;

  setFormData({

    ...formData,

    [target.name]: value,

  });

};

The code above checks to see whether or not the changed input is a checkbox. If it is, it takes the value from the checked property instead of value. Otherwise, it will take the value of the input.

With the code above, the checkbox will update properly.
Do this
Update your form

Add the code above to your form. Update your initialFormState to include a subscription key with a value of true.

const initialFormState = {

  name: "",

  email: "",

  referral: "",

  age: "",

  subscription: true,

};

Then, try selecting and then clearing the checkbox, submitting each time. Take a look at the console and make sure that your form works as intended.

*** 22.9 Assessment: React state management
** module 24 react and apis with hooks
*** 24.1 Overview: React and APIs with hooks
Overview: React and APIs with hooks
9 minutesEstimated completion time
Learning Objective

By the end of this module, you will be able to use the React effect hook. You'll be able to manually change the DOM, fetch data, and update React components.
Do this

The purpose of the Do this sections in this module is to give you important hands-on experience. In these sections, you'll perform various tasks, like setting up a development environment or executing a command. Ultimately, these practice sections will help you successfully complete graded assessments, such as projects, mock interviews, and capstones.
*** 24.2 The effect hook
The effect hook
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to fetch and update data from an API and set the document title. To do this, you'll use the effect hook.
Overview

This lesson introduces the effect hook, useEffect(), which will enable you to perform side effects from React function components.
Key Terms

Side effect
    Anything in a function or expression that affects something outside the scope of the function or expression

Imagine that you want to write a component that allows a user to update their profile. There are a few steps that you need to take to accomplish this, and it all starts with an API call. Here are the basic steps:

    When the user clicks Update profile, make an API call to an existing server to return the user's current profile.

    Allow the user to change their profile via an editable form.

    When the user clicks Submit, make another API call to save the updated user profile.

The effect hook, useEffect(), adds the ability to perform side effects from a React function component. A side effect is anything in a React component that affects something outside the scope of the function.
Understanding side effects

Start by watching the videos below, which provide a brief introduction to this topic. Then, read through the rest of the lesson and complete the practice work required. This will give you a full understanding of these concepts.

Note: Side effect (often simply called effect) isn't a term that's specific to React. It's a general concept about the behavior of a function. For example, a function that modifies a DOM element is introducing a side effect; the DOM element doesn't belong to the scope of the current function. If you aren't using React to update the state or render HTML, that's a side effect. Basically, it's any non-React thing.

Here are some examples of side effects in React function components:

    Making asynchronous API calls for data

    Updating a DOM element

    Updating a variable that isn't a local variable

    Using setInterval() or setTimeout()

Side effects are sometimes unavoidable. Imagine, for example, that you need a component to fetch data for the current user. When you make an API call to get the data for the specified user, you're introducing a side effect to the function.
Using the effect hook

You can use useEffect() to perform side effects after the state is updated and the component has rendered. You can also specify when it is necessary to rerun the effect.

The useEffect() hook accepts two arguments:

    A function to run the effect

    An optional array of dependencies for the effect function. These values determine when to rerun the effect.

After each rendering—and after updating the DOM—React invokes the function passed to useEffect().
When is the effect rerun?

The optional second parameter to useEffect()—the array of dependencies for the effect function—controls when the effect reruns. React has three different options for when the effect is rerun, and you'll learn about all three of these options next.
Run the effect after every render

By default, useEffect() runs after the first render and after every change to props or state.

The following effect sets the document title after every render.

useEffect(() => {

  document.title = `The time is now ${Date.now()}`;

});

So if you omit the optional second parameter to useEffect(), as shown above, React will run the effect after the first render and after every change to props or state.
Run the effect once

The following effect sets the document title to a value that doesn't use any state variables or props. This effect will run exactly once.

useEffect(() => {

  document.title = `Welcome to Thinkful!`;

}, []); // Pass [] to only apply the effect once

Passing an empty array as the second parameter, as shown above, tells React that the effect doesn't use any value that participates in the React data flow. This way, React knows that it's safe to run only once.
Run the effect when a value changes

You can also use state values or prop values to determine when to rerun the effect. After rendering finishes, useEffect() will look over the list of dependency values and call your effect function if any one of them has changed.

The following effect sets the document title to a custom message including the number of clicks. This effect will rerun only when the value of count changes. This is one way to increase performance and avoid unnecessary calls.

const [count, setCount] = useState(0);


useEffect(() => {

  document.title = `You clicked ${count} times`;

}, [count]); // Only rerun the effect if `count` changes

Tip

If there are multiple items in the array, React will rerun the effect if any one of them changes.
Fetching data from an API

The video below breaks down the process of fetching data with the effect hook.

In this section, you will create a component to edit a user profile. To do this, you will make an API call to fetch a user profile once, when the component is first rendered.

You will need an existing server to make the API calls. For this, you will use JSONPlaceholder, which is a free online REST API that you can use whenever you need some fake data. Here, you'll use JSONPlaceholder to fetch and save the user profile data. Note that JSONPlaceholder doesn't really save any of your data, so none of the changes that you make will be saved.
Tip

Use the global fetch() function to make API calls.

function ProfileEdit() {

  const [user, setUser] = useState({});


  useEffect(() => {

    async function loadUsers() {

      const response = await fetch(

        "https://jsonplaceholder.typicode.com/users/1"

      );

      const userFromAPI = await response.json();

      setUser(userFromAPI);

    }

    loadUsers();

  }, []); // Passing [] so that it only runs the effect once


  if (user.id) {

    // `user.id` is truthy after the API call returns

    return (

      <form name="profileEdit">

        <div>

          <label htmlFor="username">User Name:</label>

          <input

            id="username"

            name="username"

            type="text"

            value={user.username}

          />

        </div>

        <div>

          <label htmlFor="email">Email:</label>

          <input id="email" name="email" type="email" value={user.email} />

        </div>

      </form>

    );

  }

  return "Loading...";

}

When this component first renders, user is an empty object, so user.id is falsy and the component displays Loading.... Eventually, the fetch() call returns and calls setUser() with the user that's returned by the API. The call to setUser() causes the component to re-render—and this time, user.id is truthy, so the user information is displayed.
The async callback

The useEffect() callback cannot be an async function. Therefore, if you want to use async and await, you need to define and call an async function within the useEffect() callback.

Alternatively, here's a more concise syntax using the Promise interface:

useEffect(() => {

  fetch("https://jsonplaceholder.typicode.com/users/1")

    .then((response) => response.json())

    .then(setUser);

}, []);

You are welcome to use either syntax. But for consistency, all remaining examples will use async and await.
Do this
Create the <ProfileEdit> component

The video below provides an overview of using useEffect() with fetch().

Add the above <ProfileEdit> component to a React application and render it on the page. Afterward, add log() statements to determine when the various bits of code run.

Consider adding log() statements in the following locations:

    Before useEffect(): console.log('render', user)

    The first line inside of useEffect(): console.log('useEffect')

    Before setUser(userFromAPI);: console.log('setUser', userFromAPI)

You will see at least four log() statements for render() and only one log() statement for useEffect(). Remember, passing an empty dependency array ([]) to useEffect() tells React that it is safe to run the effect only once.
Why is useEffect() needed for API calls?

You might be wondering why you can't call fetch() directly rather than wrapping it in useEffect().

Consider what would happen if you didn't use useEffect(). The component would be rendered, triggering a call to fetch(), which would eventually call setUser() and update the state. Every call to update the state would trigger a re-render. The re-render would trigger another call to fetch(), and so on. The code would then be stuck in an infinite re-rendering loop. The same thing will happen if you omit the empty array as the second parameter.
Saving data to an API

The video below provides an overview of saving data with the effect hook.

Now, you will add the change and submit handlers to allow the user to make changes and submit the updated profile.

First, add the change handler to the input elements. In this case, you will use a naming convention to allow you to use the same change handler for each input. For this to work, the name of the input must be exactly the same as the property on the user object.

const changeHandler = event => {

  setUser({ ...user, [event.target.name]: event.target.value })

}


<input

  id="username"

  name="username"

  type="text"

  required={true}

  value={user.username}

  onChange={changeHandler}

/>


...


<input

  id="email"

  name="email"

  type="email"

  required={true}

  value={user.email}

  onChange={changeHandler}

/>

By making sure that the name of the input is exactly the same as the corresponding property on the user object, you can use the same change handler on each input.
Tip

In other scenarios, you might need to use more than one change handler. For example, if you want to set a value with a number input, you might need to cast the value to a number in your changeHandler() function.
Do this
Debug changeHandler

Add the above code to your <ProfileEdit> component. Make sure that you are able to type new values into both of the input boxes.

Afterward, change name="username" to name="wrongusername". Now, you can no longer type in the username input box.

Why does this happen? The changes are applied to the wrongusername property of the user, and not the username property. So when you type, the value of the input does not change.

Next, add the submit handler, which gets called when the form is submitted. The form will submit the modified user information back to the server. Use the following code:

const submitHandler = async (event) => {

  event.preventDefault();

  const response = await fetch(

    `https://jsonplaceholder.typicode.com/users/${user.id}`,

    {

      method: "PUT",

      body: JSON.stringify(user),

    }

  );

  const savedData = await response.json();

  console.log("Saved user!", savedData);

};

To save data using fetch(), add a second parameter to tell fetch() to use the PUT method and send the current user data as a string in the body of the request.
Multiple useEffect() calls to separate concerns

The video below provides an overview on using useEffect() with multiple side effects.

React allows multiple useEffect() calls inside a component. This allows the effect code to be broken down into multiple functions containing logically related code.

Now, you will extend the <ProfileEdit> component to set the document title to include the user's name whenever the user changes. With this new functionality, there are multiple side effects that need to run after the component is rendered. In one, you get the current user. In the other, you set the document title. Both of these tasks are logically independent, so they should be separated into multiple useEffect() functions so that they follow the single responsibility principle.

Here's the code to set the document title:

useEffect(() => {

  if (user.username) {

    document.title = `${user.username} : Edit Profile`;

  } else {

    document.title = "Edit Profile";

  }

}, [user]); // Rerun this effect when the user changes

When the component first renders, the fetch() call hasn't returned yet, so you don't yet know the user's name. After fetch() returns, React notices that the user reference has changed. It reruns the effect, which will then include the username in the title.

Tip: Don't call hooks inside loops, conditions, or nested functions. Instead, always use hooks at the top level of your React function. By following this rule, you can ensure that hooks are called in the same order each time that a component renders. That's what allows React to correctly preserve the state of hooks between multiple useState() and useEffect() calls.

The following is the complete <ProfileEdit> component at this point.

function ProfileEdit() {

  const [user, setUser] = useState({});


  console.log("render", user);

  useEffect(() => {

    console.log("useEffect");

    async function loadUsers() {

      const response = await fetch(

        "https://jsonplaceholder.typicode.com/users/1"

      );

      const userFromAPI = await response.json();

      console.log("setUser", userFromAPI);

      setUser(userFromAPI);

    }

    loadUsers();

  }, []); // Passing [] so that it only runs the effect once


  useEffect(() => {

    if (user.username) {

      document.title = `${user.username} : Edit Profile`;

    } else {

      document.title = "Edit Profile";

    }

  }, [user]); // Rerun this effect when the user changes


  const changeHandler = (event) => {

    setUser({ ...user, [event.target.name]: event.target.value });

  };


  const submitHandler = async (event) => {

    event.preventDefault();

    const response = await fetch(

      `https://jsonplaceholder.typicode.com/users/${user.id}`,

      {

        method: "PUT",

        body: JSON.stringify(user),

      }

    );

    const savedData = await response.json();

    console.log("Saved user!", savedData);

  };


  if (user.id) {

    return (

      <form name="profileEdit" onSubmit={submitHandler}>

        <div>

          <label htmlFor="username">User Name:</label>

          <input

            id="username"

            name="username"

            type="text"

            required={true}

            value={user.username}

            onChange={changeHandler}

          />

        </div>

        <div>

          <label htmlFor="email">Email:</label>

          <input

            id="email"

            name="email"

            type="email"

            required={true}

            value={user.email}

            onChange={changeHandler}

          />

        </div>

        <button type="submit">Save</button>

      </form>

    );

  }

  return "Loading...";

}
*** 24.3 Effect hook with cleanup
Effect hook with cleanup
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to return a cleanup function from the useEffect() hook to cancel pending API calls.
Overview

In this lesson, you'll continue building on your skills with useEffect(). You'll learn how to return a cleanup function from the effect hook, which will enable you to undo previously applied effects.

Imagine that you want to write a component that allows an admin user to update the user profile of any user on the system. To do so, you will need to pass the user's ID to the component, so that the component can do the following:

    Make an API call to get that user's profile.

    Allow the admin user to edit the profile.

    Upon form submission, make another API call to save the updated profile.

However, take a look at the image below. Did you notice that the user ID in the parent component isn't the same as the API user ID? In this lesson, you'll explore what makes this happen and how you can fix it.
User ID in the parent component is not the same as the API user ID
Avoiding race conditions

The fetch() call is asynchronous, so anything can happen between when the API call starts and ends. This can introduce race conditions; for example, you could get new props. If the code in the effect is calling an API and depends on props, you have a race condition.

To understand how this happens, look at the App.js and ProfileEdit.js files below:

In App.js:

import React, { useState } from "react";

import "../src/App.css";

import ProfileEdit from "./ProfileEdit";


function App() {

  const [userId, setUserID] = useState(1);


  const userIds = [1, 2, 3, 4];


  return (

    <div className="App">

      {userIds.map((id) => (

        <button key={id} onClick={() => setUserID(id)}>

          User ID {id}

        </button>

      ))}

      <h2>User ID {userId}</h2>

      <ProfileEdit userID={userId} />

    </div>

  );

}


export default App;

In ProfileEdit.js:

import React, { useEffect, useState } from "react";


function ProfileEdit({ userID }) {  // Added `userID` as a prop

  const [user, setUser] = useState({});


  useEffect(() => {

    async function loadUser() {

      const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userID}`);

      const userFromAPI = await response.json();

      setUser(userFromAPI);

    }


    loadUser();

  }, [userID]);  // <-- Added dependency on `userID`


  ... // Omitted for brevity

}



export default ProfileEdit;

Note that the userID is passed in as a prop to ProfileEdit, and ProfileEdit.useEffect() has a dependency on userID because it is used in the API URL.

To make the effect more noticeable, you can simulate a slower network connection in your browser. Chrome Developer Tools makes it easy to throttle your internet bandwidth. To do so, first open up DevTools, then navigate to the Network tab, and select the Slow 3G option from the menu, as follows:
Slow 3G option

Note: If you aren't using the Chrome browser, then you will have to research how to throttle the internet bandwidth for the browser of your choice.

How can you fix this so that the selected user and the user displayed for edit are always in sync?

You might consider calling setUser({ }) at the beginning of useEffect(). When you do that, "Loading..." will be displayed until the new user is returned from the API. Then, add setUser({ }); at the beginning of useEffect(). Your code will look like this:

useEffect(() => {

  setUser({});

  async function loadUser() {

    const response = await fetch(

      `https://jsonplaceholder.typicode.com/users/${userID}`

    );

    const userFromAPI = await response.json();

    setUser(userFromAPI);

  }


  loadUser();

}, [userID]); // <-- Added dependency on userID

This is better, but it doesn't completely solve the problem. Take a look at the animation below—there are still times when the user ID and the API user ID are out of sync.
User IDs out of sync

This is because an earlier call to fetch() completed after a new user ID was passed to the component. Wouldn't it be nice if you could signal to fetch() that it should cancel the current API call when the user ID changes?

You can do that by returning a cleanup function from useEffect(). The cleanup function can do anything necessary to clean up after previously applied effects. Essentially, its purpose is to undo an effect for cases like subscriptions or pending API responses.

Now, walk through what happens when the user ID prop changes from 1 to 2.

React only runs the effects after letting the browser paint. This makes your app faster, because most effects don't need to block screen updates. Effect cleanup is also delayed. The previous effect is cleaned up after the re-render with new props. The following is the sequence of events in React when the user ID prop changes from 1 to 2:

    React renders a new UI for {userId: 2}.

    The browser paints, and you see the UI for {userId: 2} on the screen.

    React cleans up the effect for {userId: 1}.

    React runs the effect for {userId: 2}.

You might be wondering what happens if you need the props or state from the first render to do the cleanup. How can the cleanup of the previous effect still "see" the old {userId: 1} props if it runs after the props change to {userId: 2}? Well, you can use a JavaScript closure to capture the props and state of the render call that defined it. Specifically, define the cleanup function as an arrow function and use the necessary props or state in the cleanup function.

Now, look at what useEffect() looks like when it returns a cleanup function that cancels the pending API call:

useEffect(() => {

  setUser({});

  const abortController = new AbortController(); // Create a new `AbortController`


  async function loadUser() {

    try {

      const response = await fetch(

        `https://jsonplaceholder.typicode.com/users/${userID}`,

        { signal: abortController.signal } // Pass the `AbortController` signal to `fetch()`

      );

      const userFromAPI = await response.json();

      setUser(userFromAPI);

    } catch (error) {

      if (error.name === "AbortError") {

        // Ignore `AbortError`

        console.log("Aborted", userID);

      } else {

        throw error;

      }

    }

  }


  loadUser();


  return () => {

    console.log("cleanup", userID);

    abortController.abort(); // Cancels any pending request or response

  };

}, [userID]);

First, you need a new instance of AbortController, which is a special built-in object. The AbortController object can be used to abort not only fetch(), but other asynchronous tasks as well.

Using AbortController with fetch() and useEffect() requires four steps:

    Create a new instance of AbortController:

const abortController = new AbortController();

Pass the signal property to fetch():

fetch(url, { signal: abortController.signal });

catch() the AbortError that is thrown when fetch() is aborted:

 try {

 ....

 } catch (error) {

   if (error.name === "AbortError") {

     // Ignore `AbortError`

     console.log("Aborted", userID);

   } else {

     throw error;

   }

 }

})

Return a cleanup function from useEffect():

    return () => abortController.abort();

Once these changes are made, the ProfileEdit component displays only the current user. Note that additional logging was added here to show the order of effect and cleanup.
API cleanup
Do this
Create the profile editor application

Add the following starter code to a React application and render it on the page.

In App.js:

import React, { useState } from "react";

import "../src/App.css";

import ProfileEdit from "./ProfileEdit";


function App() {

  const [userId, setUserID] = useState(1);


  const userIds = [1, 2, 3, 4];


  return (

    <div className="App">

      {userIds.map((id) => (

        <button key={id} onClick={() => setUserID(id)}>

          User ID {id}

        </button>

      ))}

      <h2>User ID {userId}</h2>

      <ProfileEdit userID={userId} />

    </div>

  );

}


export default App;

In ProfileEdit.js:

import React, { useEffect, useState } from "react";


function ProfileEdit({ userID }) {

  const [user, setUser] = useState({});


  useEffect(() => {

    async function loadUser() {

      const response = await fetch(

        `https://jsonplaceholder.typicode.com/users/${userID}`

      );

      const userFromAPI = await response.json();

      setUser(userFromAPI);

    }


    loadUser();

  }, [userID]); // <-- Added dependency on `userID`


  useEffect(() => {

    if (user.username) {

      document.title = `${user.username} : Edit Profile`;

    } else {

      document.title = "Edit Profile";

    }

  }, [user]); // Rerun this effect when the user changes


  const changeHandler = (event) => {

    setUser({ ...user, [event.target.name]: event.target.value });

  };


  const submitHandler = async (event) => {

    event.preventDefault();

    const response = await fetch(

      `https://jsonplaceholder.typicode.com/users/${userID}`,

      {

        method: "PUT",

        body: JSON.stringify(user),

      }

    );

    const savedData = await response.json();

    console.log("Saved user!", savedData);

  };


  if (user.id) {

    return (

      <form name="profileEdit" onSubmit={submitHandler}>

        <fieldset>

          <legend>API User ID: {user.id}</legend>

          <div>

            <label htmlFor="username">User Name:</label>

            <input

              id="username"

              name="username"

              type="text"

              required={true}

              value={user.username}

              onChange={changeHandler}

            />

          </div>

          <div>

            <label htmlFor="email">Email:</label>

            <input

              id="email"

              name="email"

              type="email"

              required={true}

              value={user.email}

              onChange={changeHandler}

            />

          </div>

          <button type="submit">Save</button>

        </fieldset>

      </form>

    );

  }

  return "Loading...";

}


export default ProfileEdit;

Afterward, modify the ProfileEdit.useEffect() function to return a cleanup function that cancels the fetch() call as you quickly click various user ID buttons.

Notice that the ProfileEdit component first renders with {userId: 1}. As you quickly click through the user ID buttons, the ProfileEdit component doesn't re-render—it continues to display {userId: 1}. Once you stop clicking the user ID buttons, it will re-render only when the fetch() call returns. Why does this happen? It's because the user state of the ProfileEdit component doesn't change until the fetch() call returns. Every time that you click a user ID button, the pending fetch() call is canceled.

Finally, add setUser( {} ); as the first line of ProfileEdit.useEffect().

When done, ProfileEdit.useEffect() will look something like the following:

useEffect(() => {

  setUser({});

  const abortController = new AbortController();


  async function loadUser() {

    try {

      const response = await fetch(

        `https://jsonplaceholder.typicode.com/users/${userID}`,

        { signal: abortController.signal }

      );

      const userFromAPI = await response.json();

      setUser(userFromAPI);

    } catch (error) {

      if (error.name === "AbortError") {

        // Ignore `AbortError`

        console.log("Aborted", userID);

      } else {

        throw error;

      }

    }

  }


  loadUser();


  return () => abortController.abort();

}, [userID]);

Now, the user ID and API user ID are always in sync, and "Loading..." is displayed during any pending fetch() calls.
*** 24.4 Assessment: React and APIs with hooks
** module 25 react router
*** 25.1 Overview: React Router
Overview: React Router
9 minutesEstimated completion time
Overview

In this module, you'll learn how to use React Router, which is the de facto library for linking a URL and React application together. You'll also learn the difference between backend (traditional) routing and frontend (React) routing.
Key Terms

Backend routing
    Routing in which every page sends a request to the server for an HTML file, and every page requires the browser to download, parse, and render a new HTML file
Frontend routing
    Routing that is handled from the browser, and the browser only sends a request to the server when necessary
Routing
    The process of keeping the browser URL in sync with what's displayed on the page

So far, you haven't had to think about updating the URL in the browser when different components are displayed on the screen. Everything has been displayed on the same URL. And as a result, there hasn't been a way to use the browser's built-in Back button to go back to previous views, or the Forward button to go forward again after having gone back.

But with modern React applications, visitors expect to be able to use the browser's Back and Forward buttons. They also expect to be able to bookmark a page so that they can come back to it later. And they expect to be able to copy the URL to share the same page content with a friend. If the URL in the browser doesn't change when the content changes, none of these things will work.

In this module, you'll learn how to use the React Router library to link URLs and React applications together. You'll also learn how traditional backend routing and React frontend routing differ. You will likely learn some new things about how the URL is used to display content, retrieve information from APIs, and even display multiple components on the page simultaneously. From the visitor's perspective, all of this is done seamlessly, but there's a lot that you need to take care of behind the scenes to make this possible. Learning new things can be challenging, so reach out for help if you're feeling stuck or frustrated.
What's routing?

Routing is the process of keeping the browser URL in sync with what's displayed on the page. Routing is key to all websites, and it comes into play whenever you use a URL in your application. URL links using the <a> tag are the standard way of navigating the web.

A traditional website uses backend routing, where every page—or route—sends a request to the server for an HTML file. Every page requires the browser to download a new HTML file from the server, parse it, download any new scripts or images, and then render it on the screen. Generally speaking, traditional websites need more computing power and internet bandwidth because more data is being downloaded. With backend routing, the server handles almost everything that the visitor does.

In contrast, frontend routing happens in the browser. In a single-page application (SPA), like those built with React, there is no request to the server for every page that you visit. The frontend router tells the application to redraw part of the page, without telling the server. This results in a page that is faster and that feels more like a native application. Generally speaking, frontend routing is a better user experience. With frontend routing, the browser only sends a request to the server when necessary.

Despite these differences, you might not be able to distinguish them at first.
Do this

The purpose of the Do this sections in this module is to give you important hands-on experience. In these sections, you'll perform various tasks, like setting up a development environment or executing a command. Ultimately, these practice sections will help you successfully complete graded assessments, such as projects, mock interviews, and capstones.
*** 25.2 Using Router, Switch, Route, and Link
Using Router, Switch, Route, and Link
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use <Router>, <Switch>, and <Route> to create frontend routes. You will also be able to use <Link> to support navigation around your application.
Overview

As you'll learn in this lesson, React Router is the de facto library for keeping React UI in sync with the URL. It has a simple API with powerful features. When you're building your app in React, React Router can help you make the URL your first thought, rather than an afterthought.
Frontend routing

The video below provides a brief introduction to frontend routing. Start by watching the video, and then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of these topics.

As the visitor navigates around the site, they expect the URL to change along with the content on the page. For example, the following image shows what happens when the visitor is on the home page and clicks the About link on the menu.
What happens when user clicks the About link.

Both pages shown above use the same index.html file and the same App.js component. Yet, when the visitor clicked the About link, both the URL and the page component changed.

Frontend navigation offers many benefits:

    It allows visitors to bookmark pages (for example, they could bookmark https://xkcd.com/722/).

    It allows visitors to share links to specific content and pages.

    It allows visitors to move forward and backward in their browsing history.

    Routing between views is generally faster than backend routing.

    Smooth transitions and animations between views are easier to implement.

    Breaking up your code by page helps promote modularity.

But it isn't all sunshine and happiness with frontend routing. You still need backend routes for resources such as images, JavaScript, CSS, API calls, and the index.html file that is your SPA.

You'll also need to make sure that page refreshes and direct access via URL both work. For example, you need to make sure that it works when the visitor types the URL in the browser bar instead of using in-app navigation.

In a simple application like the one shown above, you can use an if statement, like this:

import React from "react";


// All components in one file for simplicity only


function Home() {

  return <p>Home</p>;

}


function About() {

  return <p>About</p>;

}


function App() {

  return (

    <div className="App">

      {window.location.pathname === "/about" ? <About /> : <Home />}

    </div>

  );

}


export default App;

Now, take a look at this in action:
Routing for /about.

This style of routing works for / and /about, but it doesn't work for other routes. Routes like /about/foo and /profile display <Home>, even though they aren't valid routes.

As the complexity of your application grows, it becomes increasingly difficult to use this simple technique to keep the browser URL in sync with what's displayed on the page. Even with only two routes, there are several problems with routing in this application. Just imagine how difficult it would be to handle 10 pages with URLs like /users/42/posts/7/comments!

That's where React Router comes in. The React Router library was created specifically to solve the problem of routing in React applications. It wraps around the browser history API and provides declarative syntax to keep your React application UI in sync with the browser's URL.

To enable routing in your application, you can use the <Router> component from React Router.
Starter code

The video below provides a brief introduction to React Router.

To follow along with the code in this lesson, create a new React application using Create React App, as follows:

npx create-react-app router-exercise-app

Because this application will be using React Router, you should install that library. So when the create-react-app command is complete, cd into the new folder and install react-router-dom, like this:

cd router-exercise-app

npm i react-router-dom@"^5"

The <Router> component

All React apps use the same low-level interface—<Router>—for the router component. This is true regardless of whether you're building a React application that runs in the browser (react-dom), or one that runs on Android and iOS (react-native). However, each environment has its own high-level router implementation specific to the environment.

In the browser, you use <BrowserRouter> but alias it as <Router> for readability, as follows:

import { BrowserRouter as Router } from "react-router-dom";

Now, add <BrowserRouter> to App.js, like this:

import React from "react";

import { BrowserRouter as Router } from "react-router-dom";


function App() {

  return (

    <Router>

      <div className="App"></div>

    </Router>

  );

}

<Router> defines the scope of routing within the app. In this case, it wraps everything within the app.

Once you have a <Router> in place, you can use <Route> components to render or hide components based on the URL path.
The <Route> component

The <Route> component may be the most important component in React Router. Its responsibility is to render some UI when its path matches the current URL. Wrapping a component with <Route> is similar to wrapping it in an if statement. If the URL matches the path property of the route, the component will be rendered.

The path property of the route can be a URL path (like / or /users) or an array of URL paths (like ['/about','/contact',...]).
Tip

A <Route> without a path always matches the URL.

Now, add routes to the component, like this:

import React from "react";

import { BrowserRouter as Router, Route } from "react-router-dom";


function Home() {

  return <p>Home</p>;

}


function About() {

  return <p>About</p>;

}


function App() {

  return (

    <Router>

      <div className="App">

        <Route path="/">

          <Home />

        </Route>

        <Route path="/about">

          <About />

        </Route>

      </div>

    </Router>

  );

}

Note: If you search for information about React Router, you might see <Route> used like this: <Route path="/about" component={About}/>. This is the old way of using <Route>. As of React Router 5.1, <Route> should be written as shown above.

Check out how it behaves now:
Now /about shows both </Home> and <About>.

It seems to have gotten worse! Now /about renders both </Home> and <About>. Why is this happening? It is because <Route>, by default, doesn't use an exact match on the path property.

By default, if the URL matches the beginning of the path, it is considered a match. So in this case, a URL of /about matches the path / and the path /about.

The <Route> component has an exact property that, when set to true, means that the URL path must exactly match the route path. You could make use of the exact property to fix these issues, like this: <Route exact={true} path="/"> .... But there's also another way that you could fix this.

The routes in this app are mutually exclusive; you only want to render the first <Route> that matches the location. So you can use the <Switch> component to render only one <Route>.
The <Switch> component

The video below provides a brief introduction to the <Switch> component.

The <Switch> component will render one of its child <Route> components. It will render only the first <Route> component that has a match. It checks the path of its child <Route> components in order.

import React from "react";

import { BrowserRouter as Router, Route, Switch } from "react-router-dom";


function Home() {

  return <p>Home</p>;

}


function About() {

  return <p>About</p>;

}


function App() {

  return (

    <Router>

      <div className="App">

        <Switch>

          // by convention `/` is listed first with exact={true}

          <Route exact={true} path="/">

            <Home />

          </Route>

          <Route path="/about">

            <About />

          </Route>

        </Switch>

      </div>

    </Router>

  );

}

Now, take a look at how adding <Switch> changes the routing:
Adding <Switch> changes the routing.

That's better!

Now, add some <Link> components to the page so that the user can navigate between the Home and About pages without having to type in the address bar.
The <Link> component

The video below provides an introduction to the <Link> component.

The <Link> component provides declarative, accessible navigation around your application.

You may be tempted to use regular anchor tags (such as <a href="/">Home</a>) instead of <Link> components. Although regular anchor tags will work, they will cause your app to reload the entire page when the user clicks the link.

Once you add <Link> components, your App.js will look like this:

import React from "react";

import {

  BrowserRouter as Router,

  Link,

  Route,

  Switch,

  useLocation,

} from "react-router-dom";


function Home() {

  return <p>Home</p>;

}


function About() {

  return <p>About</p>;

}


function App() {

  return (

    <Router>

      <div className="App">

        <Link to="/">Home</Link>

        <Link to="/about">About</Link>

        <Switch>

          <Route exact={true} path="/">

            <Home />

          </Route>

          <Route path="/about">

            <About />

          </Route>

        </Switch>

      </div>

    </Router>

  );

}


export default App;

Do this
Display the <NoMatch> component for unknown routes

Add the <App>, <Home>, and <About> components from above to a React application.

Afterward, modify the code to display the following <NoMatch> component only when no other route is matched. In other words, /profile should display the <NoMatch> component, but /  and /about shouldn't.
Tip

The useLocation hook returns the location object that represents the current URL. You can think about it like a useState that returns a new location whenever the URL changes.

import { useLocation } from "react-router-dom";


function NoMatch() {

  const location = useLocation();


  return (

    <h3>

      No match for <code>{location.pathname}</code>

    </h3>

  );

}

Complete example

A completed example from this lesson can be found in the using-router-switch-and-link branch of this GitHub repository:

    React Router: Using Router, Switch and Link
*** 25.3 Organizing React code
Organizing React code
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to describe the two most common ways of organizing React code.
Overview

Like all software projects, React projects tend to get larger and more complex over time. The more files that you have in the project, the more important it becomes to organize those files in a way that makes it easy to find and modify existing code as well as add new code in a location consistent with the existing code. So in this lesson, you'll learn some approaches for organizing your code.
What's the problem?

This is the file structure created by Create React App, as of version 3.4.1:

my-app

├── README.md

├── package-lock.json

├── package.json

├── build  <-- created during build

├── node_modules

├── public

│   ├── favicon.ico

│   ├── index.html

│   ├── logo192.png

│   ├── logo512.png

│   ├── manifest.json

│   └── robots.txt

└── src

    ├── App.css

    ├── App.js

    ├── App.test.js

    ├── index.css

    ├── index.js

    ├── logo.svg

    ├── serviceWorker.js

    └── setupTests.js

This is where you start. From here, you have complete freedom to organize your code however you like.

Bear in mind that keeping all of your components in the src folder will get overwhelming, even for small applications. For example, a single-page React Resume application may have more than 20 JavaScript files to organize.

There are no rules about how to organize your code. Simply do what makes sense for you. Try both of the approaches described in this lesson, and decide which you prefer. You can always change your mind later.

However, when you're organizing your code, it's usually a good idea to avoid deep nesting.
Avoid deep nesting

Deep directory nesting in JavaScript projects can present several challenges. It is harder to write relative imports between directories, and it's harder to update those imports when moving files.

Unless you have a compelling reason to use a deep folder structure, limit yourself to three nested folders within src. This is only a recommendation, though. Seek some expert advice if you believe that deeper nesting is necessary for your project.
Grouping by file type

One common way to structure projects is to group similar files together. Here's an example:

# Common files like App.js omitted for brevity

src

├── api

│   ├── APIUtils.js

│   ├── APIUtils.test.js

│   ├── ProfileAPI.js

│   └── UserAPI.js

└── components

    ├── Avatar.css

    ├── Avatar.js

    ├── Feed.css

    ├── Feed.js

    ├── FeedStory.js

    ├── FeedStory.test.js

    ├── Profile.js

    ├── ProfileHeader.css

    └── ProfileHeader.js

As the project grows in size, the number of files in the components folder can get overwhelming. As a result, the components folder will often have nested folders that group the components in some way. Usually, the components are grouped by route, feature, or role in the application.

Some developers have even abandoned the components folder entirely; they only group the components by route, feature, or role.
Grouping by route

Another common project structure is to locate CSS, JavaScript, images, and tests together inside folders grouped by route. Grouping by route means that anything displayed on the page for a given route is in a folder with the same name as the route.

Here's an example of grouping code by route or feature:

# Common files like App.js omitted for brevity

├── about

│   ├── About.css

│   ├── About.js

│   ├── About.tests.js

│   └── headquarters.jpeg

├── header

│   ├── Header.css

│   ├── Header.js

│   ├── Header.tests.js

│   ├── NavBar.css

│   ├── NavBar.js

│   ├── NavBar.tests.js

│   └── header-background.jpeg

├── home

│   ├── Home.css

│   ├── Home.js

│   └── Home.tests.js

├── login

│   ├── Login.css

│   ├── Login.js

│   └── Login.tests.js

└── profile

    ├── Profile.js

    ├── ProfileAPI.js

    ├── ProfileHeader.css

    ├── ProfileHeader.js

    └── index.js

From this folder structure, you can see that there are routes for /about, / (home), /login, and /profile. Everything displayed on the page for each of those routes is included in the corresponding folder.

What about the header folder? That isn't a route; rather, it's a component that is displayed on multiple pages. Because its role is the header for all routes, it's in its own folder. In this case, the files are grouped by role.

If your application has nested routes (such as /user/1/post/), you may organize those components into nested folders like this:

user

├── User.js

├── User.tests.js

├── Users.css

├── Users.js

├── Users.tests.js

└── post

    ├── Post.js

    ├── Post.tests.js

    ├── Posts.css

    ├── Posts.js

    └── Posts.test.js

Or you can flatten the folders, like this:

src

├── user

│   ├── User.js

│   ├── User.tests.js

│   ├── Users.css

│   ├── Users.js

│   └── Users.tests.js

└── user-post

    ├── UserPost.js

    ├── UserPost.tests.js

    ├── UserPosts.css

    ├── UserPosts.js

    └── UserPosts.test.js

You can also group components by feature. Unfortunately, the definition of a feature isn't universal, and it is up to you to determine what a feature is.

For the remaining lessons in this module, the code will be organized using the group-by-route method.
*** 25.4 Route parameters
Route parameters
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use the useParams() hook to implement routes with parameters.
Overview

Nearly every web application needs to extract some information from the browser's URL. The parts of the URL that are variable and need to be extracted are called URL parameters. In this lesson, you'll learn how to work with these parameters.
Key Terms

URL parameter
    Also called a param, the part of a URL that is variable and that web applications need to extract

The video below provides an overview of this topic. Start by watching the video, and then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of this concept.
What's the problem?

Sometimes, you'll want to build a component that displays different data for different URLs. For example, you may build a component to display a user's profile. Given the URL http://localhost:3000/user/42, how do you extract the number 42 (representing a user's ID) to fetch the correct user profile?

For this, you can use a URL parameter.
URL parameters

A URL parameter is a placeholder in the URL that begins with a colon :. To indicate that part of a route is a parameter, you define the path with a parameter token; in other words, precede it with a colon and give it a meaningful name.

For example, the following route path will match the above URL:

<Route path="/user/:id">

  <UserProfile />

</Route>

If there are multiple parameters in the URL, each must have a unique name. For example, http://localhost:3000/user/42/post/17 has two parameters, the user ID and the post ID, so the route path is written as path="/user/:userId/post/:postId".

This allows a route to render the same component while passing the dynamic portion of the URL to that component. That way, the component can change what it renders based on the parameter.

To get access to the route params, you can use the useParams() hook.
The useParams() hook

The useParams() hook returns an object of key-value pairs of route parameters. You can use it to access the params of the current <Route>.

Continuing with the two-parameter example above, consider the following route:

<Route path="/user/:userId/post/:postId">

  <UserProfile />

</Route>

Given the route above, the <UserProfile> component can access the parameters using the useParams() hook, like this:

import React from "react";

import { useParams } from "react-router-dom";


function UserProfile() {

  const params = useParams();

  return <p>{JSON.stringify(params)}</p>;

}

The following table shows some examples of how various URLs are rendered by the <UserProfile> component:
URL
	Renders
/user/42/post/17
	{"userId":"42","postId":"17"}
/user/fred/post/params-can-be-anything
	{"userId":"fred","postId":"params-can-be-anything"}
/user/params-can-be-anything/post/%7Beven-things-that-look-like-JSON:%22value:%7D
	{"userId":"params-can-be-anything","postId":"{even-things-that-look-like-JSON:\"value:}"}

As you can see, route parameters can be anything; they can be whatever your application needs.

Now, you can combine useEffect() and useParams() to have the <UserProfile> component load different user profiles using the same <Route>.
Do this
Complete the <UserProfile> component

Add the <App>, <Home>, and <UserProfile> components shown below to a React application.

Afterward, modify the <App> and <UserProfile> components to use the useParams() and useEffect() hooks to display user profiles from https://jsonplaceholder.typicode.com/users/${userId}.

Note: The JSONPlaceholder website is a fake online REST API for testing and prototyping.

// App.js


import React from "react";

import "../src/App.css";

import { BrowserRouter as Router, Link, Route, Switch } from "react-router-dom";

import UserProfile from "./UserProfile";


function Home() {

  return <p>Home</p>;

}


function App() {

  return (

    <Router>

      <div className="App">

        <div>

          <Link to="/">Home</Link>

        </div>

        {Array(10)

          .fill()

          .map((ignoredValue, index) => index + 1)

          .map((id) => (

            <div key={id}>

              <Link to={`/user/${id}`}>User {id}</Link>

            </div>

          ))}

        <Switch>

          <Route exact={true} path="/">

            <Home />

          </Route>

        </Switch>

      </div>

    </Router>

  );

}


export default App;

// UserProfile.js


import React, { useEffect, useState } from "react";

import { useParams } from "react-router-dom";


function UserProfile() {

  const [user, setUser] = useState({});


  // Use `useParams()` and `useEffect()`

  // Load profile data from https://jsonplaceholder.typicode.com/users/${userId}


  // No need to change anything below here

  if (user.id) {

    return Object.entries(user).map(([key, value]) => (

      <div key={key}>

        <label>{key}</label>: {JSON.stringify(value)}

        <hr />

      </div>

    ));

  }

  return "Loading...";

}


export default UserProfile;

Complete example

A completed example from this lesson can be found in the route-parameters branch of this GitHub repository:

    React Router: Route Parameters

*** 25.5 Modifying the history
Modifying the history
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use the useHistory() hook to provide programmatic navigation.
Overview

In this lesson, you'll learn how to write code that lets an application create, update, or delete data before navigating to another page.
Key Terms

Programmatic navigation
    Navigation that causes a user to be redirected as a result of an event—such as logging in or saving—that occurs on a route

It is common for a web application to automatically go to a different page in response to the visitor's actions. Most often, navigation is triggered by the user clicking a link. Yet, in some situations, the application needs to create, update, or delete some data before navigating to the new page.

For example, the onClick() handler of the Save button must first save the data to the backend. Then, after the save is successful, it must return to the application dashboard. This requires programmatic navigation—some way to write code that causes the browser to go to the new page after the save is complete.
What's the problem?

The video below provides a brief introduction to this topic.

Imagine that you have been working on a React application to keep track of users. It's been going well. Visitors can see a list of users and can view user details. Visitors love it!

Now, the visitors are asking for a Delete button on the user detail page. When clicked, this button should delete the user. Then, when the delete is complete, it should display the list of users again.

You add the Delete button. But now what?
Delete button added to user detail page.

Visitors won't be happy if the browser stays on the user detail page after the delete completes. You know that a link won't work, because the visitors want to stay on the user detail page until the delete is complete.

Luckily, you can use the useHistory() hook to navigate programmatically.
The history API and the history object

The browser's history API lets you write code to interact with the browser history, trigger the browser navigation methods, and change the address bar content.

The history object is a wrapper around the browser's history API. It gives you the ability to write code that controls the navigation of the browser.
The useHistory() hook

The useHistory() hook gives you access to the history object. This hook is provided by the React Router DOM package, which you can install and use as follows:

import React from 'react'

import { useHistory } from "react-router-dom";


function MyComponent() {

  const history = useHistory();

  ...

}

Using the useHistory() hook and the history object, you can return to the /user page after the user is deleted.

You'll start with the simplest thing that you can do with the history API: going back to the previous page.
The goBack() method

A common requirement is to go back to the previous page. This should have the same effect as the user clicking the Back button on the browser. The goBack() method of the history object performs this task. Using history.goBack() navigates to the previous entry in the browser history.
Do this
Create a <BackButton> component

Create a <BackButton> component that, when clicked, will navigate the browser back to the previous page. This should behave exactly the same as clicking the Back button on the browser.

The component should look like this:

import React from "react";

import { useHistory } from "react-router-dom";


function BackButton() {

  const history = useHistory();

  return (

    <button type="button" onClick={() => history.goBack()}>

      Go Back

    </button>

  );

}

What happens if there is no previous page? Nothing—the browser just won't go back.

If you can goBack(), you should also be able to goForward().
The goForward() method

Another useful way to navigate is to go forward to the next page. You can go forward to the next page using history.goForward(), as long as there is a next page in the history.

import React from "react";

import { useHistory } from "react-router-dom";


function ForwardButton() {

  const history = useHistory();

  return (

    <button type="button" onClick={() => history.goForward()}>

      Go Forward

    </button>

  );

}

Again, nothing will happen if there is no next page in the history.
The go() method

The video below provides a brief introduction to the go() method.

The go() method allows navigation, forward or backward, multiple pages at a time. You can use positive numbers to go forward and negative numbers to go backward.

history.go(0); // Equivalent to refreshing the page

history.go(-1); // Equivalent to `history.goBack()`

history.go(-2); // Equivalent to calling `history.goBack()` twice

history.go(1); // Equivalent to `history.goForward()`

history.go(3); // Equivalent to calling `history.goForward()` three times

If you call go() with a number, and the history isn't able to move that number of pages, nothing will happen. For example, if there is one previous page in the history and you call history.go(-2), nothing will happen.

Now you know how to navigate the history that already exists. So now, you're ready to create new history—in other words, to navigate forward to a new URL—using push().
The push() method

The video below provides a brief introduction to this topic.

The push() method pushes a new entry onto the history stack and changes the current URL to the value that you specify. Take a look:

history.push("/users"); // Navigate to /users

history.push("/home?q=query"); // Navigate to /home?q=query

When you use push(), you're always navigating forward from the current page.

Given this API, you can create a <GoHomeButton> that will go to the home page when clicked. Here's an example:

import React from "react";

import { useHistory } from "react-router-dom";


function GoHomeButton() {

  const history = useHistory();

  return (

    <button type="button" onClick={() => history.push("/")}>

      Go Home

    </button>

  );

}

Because this button only goes to the home page, it would also work to use a <Link> component. But if this button did something more, like update or delete a resource, and then went to the home page, it couldn't be replaced by a <Link>.

*** 25.6 Nested routes
Nested routes
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use nested <Route> components to show more than one component at a time.
Overview

So far in this module, you've had all routes in one place. But this could be hard to manage in the future as the number of routes grows. One way that you can keep things a bit cleaner is by using nested routes, which you'll explore in this lesson.
Key Terms

Nested route
    Also called a child route, a route that is displayed inside of another route

Starter code

This lesson requires you to have the following GitHub repository running on your local machine.

    Starter-nested-routes

Fork and clone the above repository. Then, follow the instructions to get the repository to run.
What's the problem?

The video below provides a brief introduction to nested <Route> components. Start by watching the video, and then read through the rest of the lesson and complete the practice tasks. This will give you a thorough understanding of these concepts.

Sometimes, as the visitor navigates through the site, you want to change only a small part of the screen, not the entire page. You can see in the image below that as the visitor navigates between different paths (users/1, users/1/posts, and users/1/posts/:postId), some parts of the page don't change.
Some parts of the page don't change.

In the above image, the user's name and the Profile and Posts buttons stay the same visually across three different URLs; only the content below changes. One way to accomplish this routing is to create three different page components for each URL and change out the nested components to get a different view. Although this approach will work, it means that any change to the layout will require changes to multiple page components.
Nested routes

A better solution is to use nested routes to display more than one component at the same time. Nested routes, or child routes, are routes displayed inside of another route. This means that there can be more routes inside a component that is rendered by another route.
Do this

Now, add nested routes for /users/:userId/posts and /users/:userId/posts/:postId. To do that, create two new components, PostList and User, to contain the nested routes.
Create a PostList component

In the /src folder, create a new file called PostList.js containing a component called PostList, as follows:

import React from "react";

import { Route, Switch, useRouteMatch } from "react-router-dom";


function PostList() {

  return (

      <Switch>

        <Route exact path={"/users/:userId/posts"}>

          <p>Here are a list of the user’s posts</p>

        </Route>

        <Route path={"/users/:userId/posts/:postId"}>

          <p>Here is a single post</p>

        </Route>

      </Switch>

  );

}


export default PostList;

The <PostList> component returns a <Switch> component that wraps two routes, one for /users/:userId/posts and one for /users/:userId/posts/:postId. If the path in the URL matches the path for either route, then a paragraph element will be rendered. Nothing else will happen at this point.

You will learn about what useRouteMatch() does later on in the lesson.
Create a <User> component

In the /src folder, create a new file called User.js containing a component called User, as follows:

import React from "react";

import { Route, Switch } from "react-router-dom";

import UserProfile from "./UserProfile";

import PostList from "./PostList";


function User() {

  return (

    <Switch>

      <Route path={"/users/:userId/posts"}>

        <PostList />

      </Route>

      <Route path={"/users/:userId"}>

        <UserProfile />

      </Route>

    </Switch>

  );

};


export default User;

The <User> component returns a <Switch> component, which in turn wraps two nested routes. These nested routes display different components within the <User> component. The first route, which is for the /users/:userId/posts path, displays the <PostList> component. The second route, which is for the /users/:userId path displays the <UserProfile> component.
Update the /users/:userId route in the App component

Next, connect the nested routes to the top-level App component. Inside App.js, import the <User> and <PostList> components, as follows:

import PostList from "./PostList";

import User from "./User";

Next, update the <Route> component for the /users/:userId path to wrap the <User> component instead of the <UserProfile> component:

<Router>

  <Switch>

    <Route path="/users/:userId">

      <User />

    </Route>

    ...

  </Switch>

</Router>

The <App> component now has a route that displays the <User> component when the URL path matches /users/:userId. Keep in mind that the UserProfile component is now rendered by a nested route within the <User> component. Take a look at some of the code below from the <User> component:

 return (

  ...


  <Switch>

    <Route path={'/users/:userId/posts'}>

      <PostList />

    </Route>

    <Route path={'/users/:userId'}>

      <UserProfile />

    </Route>

  </Switch>

);

The <User> component has two nested routes to display different components inside of the <User> component. <Route path={'/users/:userId/posts'}> displays the <PostList> component, and <Route path={'/users/:userId'}> displays the <UserProfile> component.

In this example, when the URL matches /users/:userId, the App displays the <User> component, which in turn displays the <UserProfile> component.

If you navigate to localhost:3000/users/1, the profile for user 1 should be displayed.

Keep in mind that the <PostList> component also contains nested routes. So if you navigate to localhost:3000/users/1/posts, the page should display the "Here are a list of the user's posts" message nested inside the <PostList> component. And if you navigate to the path for a single post, localhost:3000/users/1/posts/1, the page should display the "Here is a single post" message, also nested inside the <PostList> component.

You can nest routes as much as necessary, but keep in mind it may increase the complexity of your app.
Determining the nested routes

How do you decide what should be a nested route? It's like deciding what should be a component: you can use the single-responsibility principle. That is, each route should have one thing that it does and one component that changes. Take a look:
Component route diagram

As you can see in the image above, the component with the bold border changed for that route. Of course, it's also okay to change more than one component per route. Following the single-responsibility principle isn't a firm rule; it's just a suggestion.

Exploring the above example a bit, how does the <PostList> component know that the links to its posts need to start with /users/:userId/posts/? You can hardcode the links to start with /users/:userId/posts/, but then many components need to change if the URL changes. So how can you display the component on any URL and have the links include the route that matched to display the component? You can use the useRouteMatch() hook to get the URL from the closest matching <Route> in the tree.
The useRouteMatch() hook

The video below provides a brief introduction to the useRouteMatch() hook.

The useRouteMatch() hook is useful any time that you need to get information about the closest matching <Route> in the tree. It includes the exact, strict, and sensitive options, as well as URL parameters. For example, the following is the route match information that the <PostList> component would receive when displayed at /users/1/posts.

{

   "path":"/users/:userId/posts",

   "url":"/users/1/posts",

   "isExact":true,

   "params":{

      "userId":"1"

}

Notice that the object above that contains a path property. The path property points to a path pattern which was used to match a URL, and it includes the :userId parameter. You can use the path property to create dynamic paths for your Route components. Next, you will use the path property to clean up a few nested routes in the app.
Do this
Use useRouteMatch() to clean up the nested routes

Notice that there's some repetition with the paths in the <PostList> component. All the paths here start with /users/:userId/posts. Although you can hardcode the links to start with /user/:userId/posts/, as you have done, the problem is that many components would need to be updated if the URL changes. If you miss any component, then the routing for that component will break. As you can imagine, this isn't ideal. It's better to write the nested route's path to be dynamic.

To avoid hardcoding the links, you can use the useRouteMatch() hook from the react-router-dom library to get the URL from the closest matching <Route> in the tree. Within the <PostList> component, you can now use the path property to create links that include the current URL for routes nested within <PostList>, like this:

import { Route, Switch, useRouteMatch } from "react-router-dom";


function PostList() {

  const { path } = useRouteMatch();


  return (

      <Switch>

        <Route exact path={path}>

          <p>Here are a list of the user’s posts</p>

        </Route>

        <Route path={`${path}/:postId`}>

          <p>Here is a single post</p>

        </Route>

      </Switch>

  );

}

Now, the nested routes in the <PostList> component have dynamic paths.
Complete example

A completed example from this lesson can be found in the complete branch of this GitHub repository:

    Starter-nested-routes - complete
*** 25.7 Assessment: React Router
** module 26 frontend deployment
*** 26.1 Overview: Frontend deployment
Overview: Frontend deployment
9 minutesEstimated completion time
Overview

You've learned how to build React applications. Now, it's time for you to learn how to put these React applications on the web. There are many different ways to do this, and some are easier than others. This module will begin by briefly discussing what it means to deploy an application. Then, you'll learn concrete steps that you can take to put your React application on the web.

In general, this module will focus on how to accomplish these tasks. Although there are many ways to deploy applications, you won't necessarily learn about the variety of deployment techniques here.
Do this

The purpose of the Do this sections in this module is to give you important hands-on experience. In these sections, you'll perform various tasks. For example, you may practice setting up a development environment or executing a command. Ultimately, these practice sections will help you successfully complete graded assessments, such as projects, mock interviews, and capstones.
*** 26.2 What is frontend deployment?
What is frontend deployment?
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to describe what deployment means.
Overview

Deployment is one of those technical terms that often gets thrown around without much explanation. In this lesson, you'll learn what deploying an application generally involves. You'll also learn about what kinds of services that process may include.
Sharing your work

Right now, your frontend applications can only be hosted locally. That is, if someone wants to view your website or test out your application, they'll either need to do it on your computer or download your code and run it themselves.

To make your application accessible on the web, you'll need to deploy your application. Deploying a web application typically means making it accessible on the web through a URL. Deployment is a way of sharing your work with the world by putting it on the web.
Development, staging, and production

When you deploy, you deploy to a certain environment. There are typically three environments:

    The development environment references work done on your computer.

    The staging environment references a deployed version of the application that is used to test the changes being made.

    The production environment references a deployed version of the application that is your "completed" version of the application. This version is ready for users.

The deployment process

To deploy a website, you'll need to recreate your development environment's essential components on another machine. That machine will need to be configured to run your website and will need to be connected to the internet.

Manually deploying a website and setting up an environment is an entire topic in itself, often referred to as developer operations or DevOps. Thankfully, there are a number of modern tools and services that make deployment much easier.

Keep in mind that all of these services are often configuration heavy. That means that you need to follow a certain set of steps in a particular order. It's a good idea to take your own notes on the deployment process; this can be extremely useful for later on.
Common services

There are a number of common tools and services that you may hear about when it comes to deployment. Some of the most popular options are described below.
Static website services

There are a number of services that will host a static website (with HTML, CSS, and JS) for free or for a reduced cost. GitHub allows for deploying static websites as well as domain services like GoDaddy and Name.com.

Often, services like these will be relatively simple; they won't provide many fancy tools for hosting your website.
Amazon Web Services

As one of the most popular solutions out there, Amazon Web Services (AWS) runs the web. Working with AWS can be complicated and costly for new developers, but it's an industry standard for most large websites.

AWS allows you to host applications in all kinds of languages. They provide a number of tools to facilitate this process, including their popular Elastic Beanstalk tool. They also provide a variety of other services, like file and database hosting.
Microsoft Azure

Microsoft Azure is similar to AWS in that it provides a number of different services for hosting applications of all kinds. Azure is built for large websites and projects, and it can host applications in a variety of languages.
Heroku and Vercel

Heroku is one of the more popular options, particularly among those who are just starting to code. Thanks to their easy-to-use command-line interface and excellent UI, Heroku can perform many of the same tasks that AWS and Azure can, with a bit less fuss.

Vercel, previously known as Zeit's now.sh, has become more popular as JavaScript has become more popular as both a frontend and backend language. Like Heroku, Vercel can quickly deploy React projects from the command line and offers a great UI.

Both Heroku and Vercel provide free options for users to try out the service.
*** 26.3 Building for production
Building for production
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use the build step to prepare your React application for production. You'll also be able to include environment variables specific to your React application.
Overview

Frontend applications that use the Create React App package include developer-friendly features such as helpful error messages and hot reloading. These features aren't appropriate for your users, and they come with a cost. So you'll want to remove these features when you prepare your application for production. In this lesson, you'll learn how to run the build step for your React applications. You'll also learn how to make additional changes to make your applications ready for production.

The video below provides an overview on how to prepare your app for production.
Starter code

This lesson requires you to have the following two repositories running on your local machine.

    Constellations server

    Constellations client

Fork and clone the repositories. Then, follow the instructions to get them both running.
The build process

The process of preparing your application for production is called building. When you build your application, the build process will perform several tasks, including the following:

    Creating compressed and minified versions of your assets

    Creating a single CSS file instead of adding inline <style> blocks

    Disabling any hot reloading feature or developer-friendly error messages that aren't needed for production

Before running the build step, you must first stop running the client by pressing Control+C, because you will be running the application with a special command later on after the build step. To run the build step, navigate to your starter-constellations-client folder and run the following command:

npm run build

You'll then see an output like this:
react-scripts-build output

You can see that the build step has created optimized files for the production environment and saved them inside a build folder that was also generated in the current directory.

There's a line in the output that tells you that you can deploy your build folder to production:

The build folder is ready to be deployed.

To test out this build, you can use a combination of npx and a tool called serve that will run your built React application. From the starter-constellations-client folder, run the following command:

npx serve -s build --listen 3000

The above command will run your application on port 3000. After running the command, visit the website provided to see your built application!

Now you will no longer see a list of constellations displayed on the page. Keep in mind that the build folder is created for the production environment, but you haven't set up any environment variables for production yet, so the fetch() call in the App won't work properly. This is something that you will do when you are ready to deploy the application in a future step.

Remember, you can press Control+C in the command line to close this server.
Do this
Run the build step

In the Constellations client, stop the client if it's running. Then run npm run build to create your production build, and run the npx serve -s build --listen 3000 command to get the project up and running.
Environment variables

Your application might include environment variables that are critical for the application to work in multiple environments. For frontend applications, this might include API keys or API URLs.

As you learned earlier, environment variables are key-value pairs stored in the application's environment. Your local environment will be different than the environment that you're deploying to. For crucial environment variables, you can create .env files. Create React App will look for .env files and use them to inject environment variables into the appropriate environment. For this to work, all environment variables will need to be prefixed with REACT_APP_.

A .env file's contents might look like this:

REACT_APP_API_BASE_URL=http://localhost:5000

To access this in the application, run the following:

const url = `${process.env.REACT_APP_API_BASE_URL}/constellations`;

In the above example, you may want to change REACT_APP_API_BASE_URL to a different value once the project has been deployed.
Environment files

The Create React App package provides several different file options for adding environment variables, such as .env, .env.local, .env.development, .env.production, and many more.

More information about these environment variable files can be found at Create React App's Adding Custom Environment Variables page.

In general, you can plan to work with the following:

    The .env.development file: Environment variables in this file will be used in your development environment.

    The .env.production file: Environment variables in this file will be used in your deployed production environment.

The same environment variables should appear in both of the above files. However, their values will be different.
Do this
Discover environment variables

In the Constellations client, you'll see a .env.development file with a single environment variable:

REACT_APP_API_BASE_URL=http://localhost:5000

So in the development environment, the REACT_APP_API_BASE_URL variable will be set to http://localhost:5000.

The process.env file is where the environment variables defined in the .env files for an application are stored and are made available at runtime. If you go to src/App.js, you can see that the REACT_APP_API_BASE_URL variable is being accessed via process.env and is being used to construct a URL like this:

const url = `${process.env.REACT_APP_API_BASE_URL}/constellations`;

So when you render the App component in the development environment, the url variable will be set to http://localhost:5000/constellations, because REACT_APP_API_BASE_URL is set to http://localhost:5000 in the env.development file.
*** 26.4 Vercel
Vercel
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to deploy React applications using Vercel.
Overview

In this lesson,you'll learn how to use a hosting platform called Vercel (formerly known as now.sh). With Vercel, you can deploy web applications to the cloud for free using a single command. You'll use the Vercel platform throughout this module.
Key Terms

Rolling back
    The process of going back to a previous working deploy

The video below provides a brief introduction to the process of deploying React apps using Vercel.
Starter code

This lesson requires you to have the following two repositories running on your local machine:

    Constellations server

    Constellations client

Fork and clone the repositories. Then, follow the instructions to get them both running.
Setup

Go to Vercel's website and click the Sign Up button. You can register however you like, but it's recommended to use the Continue with GitHub option. You will receive an email when your account is created and authorized.

Next, install the vercel CLI tool. To install the correct npm package, run the command given on the download page, using the npm package manager option.

If you run into any issues, contact support at the Having trouble installing? link on the page.

Now run vercel --version. It should output a version number to verify that the CLI tool has been installed.
Do this
Get set up with Vercel

Follow the instructions above to create an account with Vercel. Then, install the vercel CLI tool as described.

You won't want to use npx with the vercel command. As you'll see below, it will be configured for your machine.
Command-line configuration

For Vercel to work as intended, you need to log in via the command line. You can log in by running this command:

vercel login

It will prompt you for the email address that you used, and it will send an email to that address. You may not receive the email right away, so be patient. Also make sure to check your spam folder to see if the email might be there. Once you follow the email's instructions, the CLI will automatically exit with the following success message:

✔ Email confirmed

Congratulations! You are now logged in. In order to deploy something, run `vercel`.

Do this
Log in to Vercel

Follow the instructions above to log in to Vercel. If you encounter any problems, reach out for help.
Your first deployment

To deploy with the CLI, the command is simply vercel:

vercel

The first time that you deploy, you'll be prompted to answer a series of questions about your new project. The default values for the install will work just fine, so you can just continue to press Enter.
Tip

The first deployment for a project is always both a preview (staging) and production deployment. To redeploy to production, you will need to run vercel --prod.

This command can take a few minutes when run for the first time, so be patient. Eventually, it will say something like the following:

🔍  Inspect: https://vercel.com/<username>/starter-constellations-client/bdv6rbm90 [1s]

✅  Production: https://starter-constellations-client.vercel.app [copied to clipboard] [25s]

📝  Deployed to production. Run `vercel --prod` to overwrite later (https://vercel.link/2F).

💡  To change the domain or build command, go to https://vercel.com/<username>/starter-constellations-client/settings

The URL labeled "Inspect" in the output above is called the deployment URL. This URL is made up of several parts:

    https://: The protocol for the deployment URL

    starter-constellations-client: The deployment name, which was set using a default value when you initialized the project

    bdv6rbm90: A random unique ID that's different for each deploy. This is useful because if you ever accidentally deploy a broken application, you can roll back to a specific deploy. The random unique ID is generated for every deploy that has different code. This can get a bit cumbersome, because you could end up with multiple URLs for the same project, each with a different unique ID!

Next, the URL labeled "Production" is the production URL. After a deployment is complete, Vercel automatically aliases the latest deployment URL to the production URL. Whereas a new deployment URL is generated every time you deploy, the production URL will remain the same each time that you deploy to production.

The [copied to clipboard] note is telling you that the URL has been automatically copied; you can simply paste into your browser address bar to open your deployed app!

If you want to see more information on your deployments, you can go to your Vercel dashboard.
Do this
Deploy your application

Go into the starter-constellations-client folder and follow the instructions above to deploy your application. Beforehand, make sure that you've run npm run build.

Once completed, your deployed application should look like this:
Completed deployed application.

Right now, the deployed client won't be able to retrieve data from the server yet, as you haven't set the proper environment variables. That means that you won't see the list of constellations just yet on your deployed client. You will fix that soon.
The vercel.json file

The vercel command optionally looks for a file called vercel.json for custom configuration. This file should live in the root directory of the project.

A basic ./vercel.json file looks like the following:

{

  "version": 2,

  "routes": [

    { "handle": "filesystem" },

    { "src": "/.*", "dest": "/index.html" }

  ]

}

This code first tells Vercel that you want to use version 2 of its platform.

The routes setting is telling Vercel that any URL path that a user navigates to should be handled by the /index.html file, unless they're looking for an actual file which exists in the directory structure. So, if a request is made for /constellations, it will go to index.html.

But if a request is made for a specific file like /static/main.js or /favicon.ico, which are file paths to specific files, it will look for those files inside the build folder. So if you visit the URL <YOUR_VERCEL_PRODUCTION_URL>/favicon.ico, you will get back the favicon in the browser.

This is because your JavaScript and CSS files, as well as other static resources such as the favicon, live inside the ./build directory. React Router will handle all the other pages in ./build/index.html.
Do this
Create the configuration file

For practice, create the vercel.json file described above in your own project directory.
Redeploying

The video below provides an overview of the redeployment process.

You can redeploy your application by using the --prod flag to indicate that the app should be made available under the aliased name.

# Perform a new deploy

vercel --prod

Running the code above will update the fixed alias URL to use the latest deploy. You can create additional aliases in the Vercel dashboard, but you won't need to do that right now, because you only need one URL right now.

The Vercel CLI has many options; you can explore them in the Vercel CLI documentation.
Do this
Redeploy the client

Now, you're ready to try out making a change to your app and redeploying it. To get started, go to the src/common/Header.js file and update the h1 heading to say I love constellations instead of Explore Constellations.

After making the change, redeploy the application by running the command vercel --prod from the starter-constellations-client folder. You will have to wait for a bit for the deployment to complete, so be patient.

After the deployment process is complete, visit the deployed client again. You'll see that the text has changed.
Text is changed in deployed client.
Deploy the server to Vercel

The Constellations server has been set up so that it can be deployed to Vercel. The deployed version is simpler than the standard version and will respond with all of the constellation information, no matter the request.

Go into the starter-constellations-server folder and follow the instructions to deploy with Vercel once again. This time, you will end up with a URL that looks something like this:

https://starter-constellations-server.vercel.app

Add a new environment file

Next, connect your deployed Constellations client to your deployed Constellations server. In the client, notice that there is an .env.development file that points to http://localhost:5000. You now want to point the deployed client to the URL of the live server that you deployed in the last step.

To do so, first create a new file called .env.production in the constellations client. Include the following line inside of it, which will update the REACT_APP_API_BASE_URL to point to a live server. Replace <URL> with the URL of your deployed server.

Note: Make sure that there is no trailing slash / at the end of what you paste below.

REACT_APP_API_BASE_URL=<URL>

Also add the environment file to .gitignore.
Deploy your changes

From the Constellations client folder, run the vercel --prod command to redeploy your application. Your application will now show some constellation information.
Rolling back changes

You can check all of your deployments in the Vercel dashboard on the deployments page. If you ever accidentally deploy a broken application, you may want to quickly go back to your previous deploy.

This process of going to a previous working deploy is called rolling back. Vercel makes a rollback available in one command; you can update your alias to use the previous unique deployment URL.

To roll back, run the following code:

vercel alias [previous-deploy-url] [alias]

# Here's an example:

vercel alias https://starter-constellations-client-hjqczyxcu.vercel.app starter-constellations-client-[prod]

You can also manage your aliases on the Vercel dashboard, and you can look at a deploy's source code. For any of your deployed applications, click the deployment URL and then click the Source button in the top right of the dashboard.

*** 26.5 Automate with npm
Automate with npm
1.5 hoursEstimated completion time
Learning Objective

By the end of this lesson, you will be able to use npm pre and post scripts to run multiple commands in sequence.
Overview

As you've seen, Vercel makes the deployment process pretty manageable. However, it's easy to forget certain steps of the process when you're deploying often, or if you haven't deployed in a while. In this lesson, you'll leverage npm to combine multiple parts of the deployment process into a single command. This will help you minimize mistakes while deploying.
Key Terms

Pre hook
    A script that runs before other scripts
Post hook
    A script that runs after other scripts

Starter code

This lesson requires you to have the Constellations client running on your local machine.

Fork and clone the GitHub repository linked above. Then, follow the instructions to get it running.
Pre and post scripts

Begin by opening your package.json file.

When you run npm scripts—for example, when you run npm start, npm test, or npm run build—npm offers many features. You can create your own custom scripts, and you can also create scripts that run before or after other scripts automatically. The scripts that run before or after other scripts are called pre hooks and post hooks, respectively.

For example, take a look below at the custom script, which echoes the word hello:

  "scripts": {

    "start": "react-scripts start",

    "build": "react-scripts build",

    "test": "react-scripts test",

-   "eject": "react-scripts eject"

+   "eject": "react-scripts eject",

+   "hello": "echo 'hello!'"

  },

You could run this script with npm run hello, and it will echo hello. Take a look:

$ npm run hello


> bookmarks@0.1.0 hello /path/to/bookmarks-app

> echo 'hello!'


hello!

Suppose that you want to always run another script before the "hello" script, and another script after hello is printed. You can use pre hooks to run before the script, and post hooks to run after, as follows:

  "scripts": {

    "start": "react-scripts start",

    "build": "react-scripts build",

    "test": "react-scripts test",

    "eject": "react-scripts eject",

+   "prehello": "echo 'before hello!'",

+   "posthello": "echo 'after hello!'",

    "hello": "echo 'hello!'"

  },

Now, were you to run npm run hello, you'd see that the "prehello" script is automatically triggered before, and the "posthello" is automatically triggered after.

$ npm run hello


> bookmarks@0.1.0 prehello /path/to/bookmarks-app

> echo 'before hello!'


before hello!


> bookmarks@0.1.0 hello /path/to/bookmarks-app

> echo 'hello!'


hello!


> bookmarks@0.1.0 posthello /path/to/bookmarks-app

> echo 'after hello!'


after hello!

You can use custom scripts with pre and post hooks to automate a number of steps for your deployment.
Do this
Run tests before building

It helps to understand why it is useful to use custom scripts with pre and post hooks. You can use this pattern to automate a number of steps during the deployment process. It's good to get in the habit of always running tests right before you create a production. So you can add a pre hook for the "build" script to trigger the tests, like this:

  "scripts": {

    "start": "react-scripts start",

+   "prebuild": "react-scripts test",

    "build": "react-scripts build",

    "test": "react-scripts test",

    "eject": "react-scripts eject"

  },

If you run a build, the tests start. However, there are two problems: First, the tests start in watch mode and wait for you to manually close them. Second, if the tests fail, you don't really want the build to happen. But currently, the build is set to happen regardless of whether or not the tests fail.

To solve these problems, you can use a Create React App feature that looks for an environment variable called CI, which stands for continuous integration. When the CI environment variable is present, Create React App does the following:

    Disables watch mode in tests.

    Makes the tests output an error exit code when the tests fail. This will prevent the next scripts from running.

    Disables colors in the test output. But, colors are helpful! So you can add colors back with the --colors flag.

Update the "prebuild" script with the CI environment variable and --colors flag:

  "scripts": {

    "start": "react-scripts start",

-   "prebuild": "react-scripts test",

+   "prebuild": "CI=true react-scripts test --colors",

    "build": "react-scripts build",

    "test": "react-scripts test",

    "eject": "react-scripts eject"

  },

Tip

If you are a Windows user and you are getting an error, you may need to add env to the prebuild: "prebuild": "env CI=true react-scripts test --colors",.

Run a build now, and you'll see the tests run first. And if you break a test, the broken test will prevent the build from happening—just what you want!

Because you made some changes to your Header component earlier on, your snapshot tests are probably failing. To accept the changes made to the Header component and make the tests pass again, you’d have to update the snapshots by running this command:

npm run test -- -u

The command above will run your tests in watch mode. Make sure to press a to run all tests.

After updating the snapshots, press q to stop the tests and regain control of the terminal.

Now, if you run npm run build, the build process should run smoothly.
Create a deploy script

You can also make a custom script for deploying, and you can trigger a build before every deploy.

  "scripts": {

    "start": "react-scripts start",

    "prebuild": "CI=true react-scripts test --colors",

    "build": "react-scripts build",

    "test": "react-scripts test",

    "eject": "react-scripts eject",

+   "predeploy": "npm run build",

+   "deploy": "vercel --prod"

  },

With the "prebuild", "predeploy", and "deploy" scripts in place, you have automated multiple steps for each deploy. Every time that you want to deploy your application, it will do the following:

    Run the tests.

    If the tests succeed, run the build.

    Deploy to production with vercel --prod.

Make the changes described above. Then run this command:

npm run deploy

This will run your tests. Then, when they pass, it will generate a new build. And finally, it will deploy your new build.
*** 26.6 Heroku
Heroku
1 hourEstimated completion time
Learning Objective

By the end of this lesson, you will be able to deploy React applications using Heroku.
Overview

In this lesson, you are going to deploy an app using Heroku. Heroku, like Vercel, allows you to deploy web applications to the cloud for free using a couple of commands.
Setup

Go to Heroku's website and click the Sign Up button. You will receive an email when your account is created and authorized.

Next, install the heroku CLI tool. To install the correct npm package, run the command given on the download page, using the npm package manager option.

npm install -g heroku

Now, run heroku --version. It will output a version number to verify that the CLI tool has been installed.
Do this
Get set up with Heroku

Follow the instructions above to create an account with Heroku. Then, install the heroku CLI tool as described.
Command-line configuration

For Heroku to work as intended, you need to log in via the command line. You can log in by running this command:

heroku login

After entering the command, you will get something like this:

heroku: Press any key to open up the browser to login or q to exit:

Press any key (except q) to log in.
Do this
Log in to Heroku

Follow the instructions above to log in to Heroku. If you encounter any problems, reach out for help.
Deploying to Heroku

To deploy with the CLI, you first need to create a Heroku application with the heroku create command:

heroku create my-application

This command will return an URL that points to your deployed application. A second URL is also generated that points to a remote Git repository for the application. So your output could look something like this:

 Creating ⬢ my-application... done

 https://my-application.herokuapp.com/ | https://git.heroku.com/my-application.git

Do this
Create a React app from scratch

Create a new React app from scratch using the create-react-app command that you learned in the Rendering with React module. You can call it heroku-deployment-app-demo or whatever you prefer.

npx create-react-app heroku-deployment-app-demo

Do this
Deploy to Heroku

Now, cd into your newly created app.

cd heroku-deployment-app-demo

Before deploying to Heroku, you must initialize a Git repo, as follows:

git init

Now, use heroku create to create the heroku application:

heroku create

You will see something similar to this:

Creating app... done, ⬢ limitless-plains-57398

https://limitless-plains-57398.herokuapp.com/ | https://git.heroku.com/limitless-plains-57398.git

If you did not set a name, the heroku create command will assign a random ID to your app (limitless-plains-57398, in this case). It will also create the URL to your app (https://limitless-plains-57398.herokuapp.com/) and an empty Git repository (https://git.heroku.com/limitless-plains-57398.git).

You now have created an empty app on Heroku, so it's time to add your code and commit it.

git add .

git commit -m "Add react app"

Now, push your code to Heroku.

git push heroku main

To see your deployed app, use heroku open.

heroku open

You will see something like this.
Screen of deployed app with Heroku.
Redeploying

Redeploying your app is very simple: push your new changes to Heroku.

git add .

git commit -m "Added new feature to app"

git push heroku main
*** 26.7 Assessment: Frontend deployment
